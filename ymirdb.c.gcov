        -:    0:Source:ymirdb.c
        -:    0:Graph:ymirdb.gcno
        -:    0:Data:ymirdb.gcda
        -:    0:Runs:186
        -:    1:/**
        -:    2: * comp2017 - assignment 2
        -:    3: * Tim Yang
        -:    4: * yyan0195
        -:    5: */
        -:    6:
        -:    7:#include <stdio.h>
        -:    8:#include <stdlib.h>
        -:    9:#include <string.h>
        -:   10:#include <strings.h>
        -:   11:#include <stdbool.h>
        -:   12:#include <ctype.h>
        -:   13:#include <limits.h>
        -:   14:#include "ymirdb.h"
        -:   15:#define TEST 0
        -:   16:#define PRINT_COMMAND 0
        -:   17:#define MSG_NOKEY printf("no such key\n");
        -:   18:#define MSG_NOSNAP printf("no such snapshot\n");
        -:   19:#define MSG_NOPERM printf("not permitted\n");
        -:   20:#define MSG_OK printf("ok\n");
        -:   21:
        -:   22:entry** get_forward_links(entry* e, int* size);
        -:   23:void entry_recalcsmm(entry* e);
        -:   24:void entry_free(entry* e);
        -:   25:// void entry_remove_from_forward(entry* e, entry* target);
        -:   26:// void entry_remove_from_backward(entry* e, entry* target);
        -:   27:// void entry_remove_entry_from_values(entry* e, entry* target);
        -:   28:// void entry_replace_entry_from_values(entry* e, entry* target, entry* replacement);
        -:   29:// void entry_replace_entry_from_backward(entry* e, int target);
        -:   30:// void entry_replace_entry_from_forward(entry* e, int target);
        -:   31:
        -:   32:void _inspect_state();
        -:   33:
    #####:   34:void fwrapper_entry(entry* e, void f(entry*)){
    #####:   35:	if (e == NULL) {
    #####:   36:		MSG_NOKEY
        -:   37:	} else {
    #####:   38:		f(e); //TODO: make it so teh push is not atoi
    #####:   39:		MSG_OK
        -:   40:	}
    #####:   41:}
        -:   42:
    22246:   43:void update_is_simple(entry* e){
    22246:   44:	if (e->forward_size > 0){
    22209:   45:		e->is_simple = false;
        -:   46:	} else {
       37:   47:		e->is_simple = true;
        -:   48:	}
    22246:   49:}
        -:   50:
       52:   51:void swap(void* a1, int idx1, int idx2, size_t size_each_elem){
       52:   52:	void* temp = calloc(1, size_each_elem);
       52:   53:	memcpy(temp, a1+idx1*size_each_elem, size_each_elem); 
       52:   54:	memcpy(a1+idx1*size_each_elem, a1+idx2*size_each_elem, size_each_elem);
       52:   55:	memcpy(a1+idx2*size_each_elem, temp, size_each_elem);
       52:   56:	free(temp);
       52:   57:}
        -:   58:
      186:   59:void command_bye() {
      186:   60:	printf("bye\n");
      186:   61:}
        -:   62:
    #####:   63:void command_help() {
    #####:   64:	printf("%s", HELP);
    #####:   65:}
        -:   66:
        -:   67:// Returns if a string follows a numeric format (positive/negative int)
  2017588:   68:bool string_isnumeric(char* string){
  2017588:   69:	char* cursor = string;
  2017588:   70:	if (*cursor == '-'){
       60:   71:		cursor++;
        -:   72:	}
        -:   73:
  2052095:   74:	while (*cursor != '\0'){
  2033356:   75:		if (!isdigit(*cursor)){
  1998849:   76:			return false;
        -:   77:		}
    34507:   78:		cursor++;
        -:   79:	}
    18739:   80:	return true;
        -:   81:}
        -:   82:
        -:   83:// TEMP: Just making the function print out the entry for now, will make it return a string instead later
      923:   84:void entry_tostring(entry* e){
      923:   85:	char* string = calloc(e->length*2, sizeof(char));
      923:   86:	printf("[");
     9354:   87:	for (int i = 0; i < e->length; i++){
     8431:   88:		element* current_element = (e->values+i);
     8431:   89:		if (current_element->type == ENTRY){
      632:   90:			printf("%s", current_element->entry->key);
        -:   91:		} else {
     7799:   92:			printf("%d", current_element->value);
        -:   93:		}
        -:   94:		
     8431:   95:		if (i != e->length-1){
     7508:   96:			printf(" ");
        -:   97:		}
        -:   98:		
        -:   99:		//TODO: Write recursive function that converts links to other keys to strings within current string.
        -:  100:	}
      923:  101:	printf("]\n");
      923:  102:	free(string);
        -:  103:	// return string;
      923:  104:}	
        -:  105:
        -:  106:
        -:  107:// Returns an entry given the key and the current state's last entry
  2026666:  108:entry* entry_get(char* key, entry** current_state_ptr){
        -:  109:	// Perform linear search over current database
  2026666:  110:	entry* cursor = *current_state_ptr;
683021661:  111:	while (cursor != NULL){
683016974:  112:		if (strcmp(key, cursor->key) == 0){
  2021979:  113:			return cursor;
        -:  114:		}
680994995:  115:		cursor = cursor->next;
        -:  116:	}
     4687:  117:	return NULL;
        -:  118:}
        -:  119:
        -:  120:// Connects e to forward by first resizing reference arrays and own size variables and then by adding references
  1998477:  121:void entry_connect(entry* e, entry* forward){
        -:  122:
        -:  123:	// Resize the memory 
  1998477:  124:	e->forward_size++;
  1998477:  125:	e->forward = realloc(e->forward, (e->forward_size)*sizeof(entry*));
  1998477:  126:	forward->backward_size++;
  1998477:  127:	forward->backward = realloc(forward->backward, (forward->backward_size)*sizeof(entry*));
        -:  128:
        -:  129:	// Add forward reference and backward references to the end of the list
  1998477:  130:	e->forward[e->forward_size-1] = forward;
  1998477:  131:	forward->backward[forward->backward_size-1] = e;
        -:  132:
  1998477:  133:}
        -:  134:
        -:  135:// Creates values array for entry from cmdline args and the current state
    26804:  136:element* elements_create(char** args, size_t args_size, entry** current_state_ptr){
    26804:  137:	element* elements = calloc(args_size, sizeof(element)); 
  2034640:  138:	for (int i = 0; i < args_size; i++){
  2007836:  139:		element* current_elem = elements + i;
  2007836:  140:		char* current_arg = args[i];
  2007836:  141:		if (string_isnumeric(current_arg)){
     9271:  142:			current_elem->type = INTEGER;		
     9271:  143:			current_elem->value = atoi(current_arg);
        -:  144:		} else {
  1998565:  145:			current_elem->type = ENTRY;
  1998565:  146:			entry* forward_link = entry_get(current_arg, current_state_ptr);
  1998565:  147:			current_elem->entry = forward_link;
        -:  148:		}
        -:  149:	}
    26804:  150:	return elements;
        -:  151:}
        -:  152:
        -:  153:// TODO: Deal with potential undefined behaviour from strings e.g. strlen not copying the null byte
        -:  154:// TODO: Include creation of complex entries i.e. ones with links to other keys (should include char* values) instead of int* values?;
        -:  155:// ? Note that the keys and values must also be inputted in the order that they are stored in so we probably cannot just have int array.
        -:  156:// Used to create simple entries (We create this in the main function then pass the entry around to other functions)
        -:  157:
        -:  158:// Returns if a key is a valid key that is alphabetical and of valid length
     4615:  159:bool key_isvalid(char* key){
     4615:  160:	if (!isalpha(*key) || strlen(key) > 15) return false;
     4599:  161:	return true;
        -:  162:}
        -:  163:
        -:  164:
        -:  165:// Creates an entry based on args given, connects entry to all relevant forward links (both sides)
     4615:  166:entry* entry_create(char** args, size_t args_size, entry** current_state_ptr){
        -:  167:
     4615:  168:	if (args_size <= 1){
    #####:  169:		printf("Cannot create an an entry with no key or with a key but has no values\n");
    #####:  170:		return NULL;
        -:  171:	}
        -:  172:
     4615:  173:	if (!key_isvalid(args[0])){
       16:  174:		MSG_NOPERM
       16:  175:		return NULL;
        -:  176:	}
        -:  177:
     4599:  178:	char* key = args[0];
     4599:  179:	entry* e = (entry *)calloc(1, sizeof(entry)); 
     4599:  180:	e->is_simple = true;
     4599:  181:	e->has_visited = false;
     4599:  182:	e->copy_reference = NULL;
        -:  183:
        -:  184:	// Check if entry contains links to other keys & keys exist & no loop to self
    14066:  185:	for (int i = 1; i < args_size; i++){
     9495:  186:		char* arg = args[i];
     9495:  187:		if (string_isnumeric(arg) == false){
      276:  188:			e->is_simple = false;
      276:  189:			entry* forward_link = entry_get(arg, current_state_ptr);
        -:  190:			
      276:  191:			if (strcmp(key, arg) == 0){
       12:  192:				MSG_NOPERM;
       12:  193:				entry_free(e);
       12:  194:				return NULL;
      264:  195:			} else if (forward_link == NULL){
       16:  196:				MSG_NOKEY
       16:  197:				entry_free(e);
       16:  198:				return NULL;
        -:  199:			}  
        -:  200:
        -:  201:
        -:  202:			// Connect elements if forward link is valid (handles adding to )
      248:  203:			entry_connect(e, forward_link);
        -:  204:		}
        -:  205:	}
        -:  206:
        -:  207:	// Set key for entry
        -:  208:	// e->values = calloc(args_size-1, sizeof(element));
     4571:  209:	memcpy(e->key, key, strlen(key)+1);
        -:  210:
        -:  211:	// Set elements for entry
     4571:  212:	e->values = elements_create(args+1, args_size-1, current_state_ptr);
     4571:  213:	e->length = args_size-1;
        -:  214:
        -:  215:	// Set max, min, sum
     4571:  216:	entry_recalcsmm(e);
        -:  217:
     4571:  218:	return e;
        -:  219:}
        -:  220:
        -:  221:// Adds the entry to the database state (current_state)
     4495:  222:void state_push(entry* e, entry** current_state_ptr){
     4495:  223:	if (*current_state_ptr == NULL){
      174:  224:		*current_state_ptr = e;
        -:  225:	} else {
        -:  226:		// Add the entry to stack (current_state)
     4321:  227:		entry* old_state = *current_state_ptr;
     4321:  228:		*current_state_ptr = e;
     4321:  229:		(*current_state_ptr)->next = old_state;
     4321:  230:		old_state->prev = *current_state_ptr;
        -:  231:	}
     4495:  232:}
        -:  233:
        -:  234:// O(n) returns true if appended/pushed are valid -> prints errors.
    22233:  235:bool _entry_values_change_is_valid(entry* e, size_t len, element* elements){
        -:  236:    // Check none of the elements pushed result in cycle or non-existant key
  2020542:  237:    for (int i = 0; i < len; i++){
  1998361:  238:        element* current_element = elements+i;
  1998361:  239:        if (current_element->type == ENTRY){
  1998293:  240:            entry* forward_link = current_element->entry;
  1998293:  241:            if (forward_link == NULL){
       32:  242:                MSG_NOKEY
       32:  243:                return false;
  1998261:  244:            } else if (strcmp(forward_link->key, e->key) == 0){
       20:  245:                MSG_NOPERM
       20:  246:                return false;
        -:  247:            }
        -:  248:        }
        -:  249:    }
    22181:  250:    return true;
        -:  251:}
        -:  252:
        -:  253:// Appends values to an entry's values array, returns false if failed
    22084:  254:bool entry_append(entry* e, char** args, size_t args_size, entry** current_state_ptr){
        -:  255:	// Create array of elements to attach to the entry
    22084:  256:	element* elements = elements_create(args, args_size, current_state_ptr);
        -:  257:    
    22084:  258:    if (!_entry_values_change_is_valid(e, args_size, elements)){
       20:  259:        free(elements);
       20:  260:        return false;
        -:  261:    }
        -:  262:    
    22064:  263:	int old_length = e->length;
    22064:  264:	e->length = e->length + args_size;
    22064:  265:	e->values = realloc(e->values,	(e->length)*sizeof(element)); 
    22064:  266:	memcpy(e->values+old_length, elements, sizeof(element)*args_size);
        -:  267:
        -:  268:	// TODO: Go to each new element that is a char and attach back links to current element
  2020176:  269:	for (int i = 0; i < args_size; i++){
  1998112:  270:		element* current_element = elements+i;
  1998112:  271:		if (current_element->type == ENTRY){
  1998088:  272:			entry* forward_link = current_element->entry;
  1998088:  273:			entry_connect(e, forward_link);
        -:  274:		} 
        -:  275:	}	
        -:  276:
    22064:  277:	free(elements);
    22064:  278:	entry_recalcsmm(e);
    22064:  279:    update_is_simple(e);
    22064:  280:	return true;
        -:  281:}
        -:  282:
        -:  283:// Reverses an array in O(n) time
      117:  284:void _reverse_array(void* array, int length, size_t size){
      161:  285:	for (int i = 0; i < length/2; i++){
       44:  286:		swap(array, i, length-i-1, size);
        -:  287:	}
      117:  288:}
        -:  289:
        -:  290:// Pushes values to an entry's values array, returns false if failed
      149:  291:bool entry_push(entry* e, char** args, size_t args_size, entry** current_state_ptr){
        -:  292:	// Create array of elements to attach to the entry
      149:  293:	element* elements = elements_create(args, args_size, current_state_ptr);
        -:  294:
      149:  295:    if (!_entry_values_change_is_valid(e, args_size, elements)){
       32:  296:        free(elements);
       32:  297:        return false;
        -:  298:    }
        -:  299:
        -:  300:
      117:  301:    _reverse_array((void*)elements, (int)args_size, sizeof(element));
      117:  302:	e->length = e->length + args_size;
      117:  303:	e->values = realloc(e->values,	(e->length)*sizeof(element)); 
      117:  304:	memmove(e->values+args_size, e->values, sizeof(element)*(e->length-args_size));
      117:  305:	memcpy(e->values, elements, sizeof(element)*args_size);
        -:  306:
      302:  307:	for (int i = 0; i < args_size; i++){
      185:  308:		element* current_element = elements+i;
      185:  309:		if (current_element->type == ENTRY){
      141:  310:			entry* forward_link = current_element->entry;
      141:  311:			entry_connect(e, forward_link);
      141:  312:			e->is_simple = false;
        -:  313:		} 
        -:  314:	}	
        -:  315:
      117:  316:	free(elements); // Remove the elements array (copy is in entry)
      117:  317:	entry_recalcsmm(e);
      117:  318:	update_is_simple(e);
      117:  319:    return true;
        -:  320:}
        -:  321:
        -:  322:// Prints out the minimum value for an entry
        8:  323:void entry_min(entry* e){
        8:  324:	int min = e->min;
        8:  325:	int forward_size = 0;
        8:  326:	entry** forwards  = get_forward_links(e, &forward_size);
        -:  327:
     4032:  328:	for (int i = 0; i < forward_size; i++){
     4024:  329:		if (forwards[i]->min < min){
        8:  330:			min = forwards[i]->min;
        -:  331:		}
        -:  332:	}
        -:  333:
        -:  334:	// printf("Minimum value is: %d\n", min);
        8:  335:	printf("%d\n", min);
        -:  336:
        8:  337:	if (forward_size > 0){
        8:  338:		free(forwards);
        -:  339:	}
        -:  340:
        8:  341:}
        -:  342:
        -:  343:// Prints out the maximum value for an entry
       12:  344:void entry_max(entry* e){
       12:  345:	int max = e->max;
       12:  346:	int forward_size = 0;
       12:  347:	entry** forwards  = get_forward_links(e, &forward_size);
        -:  348:	
     4064:  349:	for (int i = 0; i < forward_size; i++){
     4052:  350:		if (forwards[i]->max > max){
     4000:  351:			max = forwards[i]->max;
        -:  352:		}
        -:  353:	}
        -:  354:	
        -:  355:	// printf("Maximum value is: %d\n", max);
       12:  356:	printf("%d\n", max);
        -:  357:
       12:  358:	if (forward_size > 0){
       12:  359:		free(forwards);
        -:  360:	}
       12:  361:}
        -:  362:
        -:  363:// Helper function to calculate sum for entries
        -:  364:// int _calculate_sum(entry* e){
        -:  365:// 	int sum = e->sum;
        -:  366:// 	for (int i = 0; i < e->forward_size; i++){
        -:  367:// 		sum += _calculate_sum(e->forward[i]);
        -:  368:// 	}
        -:  369:// 	return sum;
        -:  370:// }
        -:  371:
      204:  372:int _calculate_sum(entry* e){
      204:  373:	if (e->has_visited){
       80:  374:		return e->sum_forward;
        -:  375:	}
        -:  376:	
      124:  377:	int sum = e->sum;
      292:  378:	for (int i = 0; i < e->forward_size; i++){
      168:  379:		sum += _calculate_sum(e->forward[i]);
        -:  380:	}
        -:  381:
      124:  382:	e->sum_forward = sum;
      124:  383:	e->has_visited = true;
      124:  384:	return sum;
        -:  385:}
        -:  386:
        -:  387:
        -:  388:
       36:  389:void entry_sum(entry* e){
        -:  390:	// _inspect_state();
        -:  391:	// int sum = e->sum;
        -:  392:	// int forward_size = 0;
        -:  393:	// entry** forwards  = get_forward_links(e, &forward_size);
        -:  394:
        -:  395:	// for (int i = 0; i < forward_size; i++){
        -:  396:	// 	sum += forwards[i]->sum;
        -:  397:	// }
        -:  398:
        -:  399:	// printf("Sum of values is: %d\n", sum);
        -:  400:	// if (forward_size > 0){
        -:  401:	// 	free(forwards);
        -:  402:	// }
        -:  403:
        -:  404:	// Clear sum
       36:  405:	int forward_size = 0;
       36:  406:	entry** forwards  = get_forward_links(e, &forward_size);
       36:  407:	int sum = _calculate_sum(e);
        -:  408:	
        -:  409:	// Get all of e's unique forward links and clear 	
       36:  410:	e->has_visited = false;
      124:  411:	for (int i = 0; i < forward_size; i++){
       88:  412:		forwards[i]->has_visited = false;
       88:  413:		forwards[i]->sum_forward = 0;
        -:  414:	}
        -:  415:	
        -:  416:	// Free memory for forwards array
       36:  417:	if (forward_size > 0){
       28:  418:		free(forwards);
        -:  419:	}
        -:  420:
        -:  421:	
        -:  422:	// printf("Sum of values is: %d\n", sum);
       36:  423:	printf("%d\n", sum);
        -:  424:
       36:  425:}
        -:  426:
        -:  427:// Helper function to calculate length for entries
      180:  428:int _calculate_len(entry* e){
      180:  429:	if (e->has_visited){
       80:  430:		return e->len_forward;
        -:  431:	}
        -:  432:	
      100:  433:	int len = e->length - e->forward_size;
      252:  434:	for (int i = 0; i < e->forward_size; i++){
      152:  435:		len += _calculate_len(e->forward[i]);
        -:  436:	}
        -:  437:
      100:  438:	e->len_forward = len;
      100:  439:	e->has_visited = true;
      100:  440:	return len;
        -:  441:}
        -:  442:
        -:  443:// Private method used by entry_len to get the DFS counting length of a general entry
       28:  444:int entry_len(entry* e){
        -:  445:	
        -:  446:	// int len = e->length-e->forward_size;
        -:  447:	// int forward_size = 0;
        -:  448:	// entry** forwards  = get_forward_links(e, &forward_size);
        -:  449:
        -:  450:	// for (int i = 0; i < forward_size; i++){
        -:  451:	// 	entry* forward = forwards[i];
        -:  452:	// 	len += forward->length-forward->forward_size;
        -:  453:	// }
        -:  454:
        -:  455:	// printf("The number of values in the entry is: %d\n", len);
        -:  456:
        -:  457:	// if (forward_size > 0){
        -:  458:	// 	free(forwards);
        -:  459:	// }
        -:  460:	
        -:  461:	// return len;
        -:  462:	// Get forward uniques first so we can clear has_visited later
       28:  463:	int forward_size = 0;
       28:  464:	entry** forwards  = get_forward_links(e, &forward_size);
       28:  465:	int len = _calculate_len(e);
        -:  466:	
        -:  467:	// Get all of e's unique forward links and clear forward_visited
       28:  468:	e->has_visited = false;
      100:  469:	for (int i = 0; i < forward_size; i++){
       72:  470:		forwards[i]->has_visited = false;
       72:  471:		forwards[i]->len_forward = 0;
        -:  472:	}
        -:  473:	
        -:  474:	
        -:  475:	// Free memory for forwards array
       28:  476:	if (forward_size > 0){
       16:  477:		free(forwards);
        -:  478:	}
        -:  479:	
        -:  480:	// printf("The number of values in the entry is: %d\n", len);
       28:  481:	printf("%d\n", len);
        -:  482:	
       28:  483:	return len;
        -:  484:}
        -:  485:
        -:  486:// Frees an entry and all its associated arrays
     9323:  487:void entry_free(entry* e){	//! Changed so entry free frees the entry and its forward references -> causes memory issues elsewhere.
        -:  488:	// Free all values pointed to by e
     9323:  489:	if (e->values != NULL) free(e->values);
     9323:  490:	if (e->forward != NULL) free(e->forward);
     9323:  491:	if (e->backward != NULL) free(e->backward);
    9323*:  492:	if (e->copy_reference != NULL) free(e->copy_reference);
     9323:  493:	free(e);
     9323:  494:}
        -:  495:
        -:  496:// TODO: You must use the entry e as the new entry as the other entries are backward linked to it
        -:  497:
        -:  498:// TODO: Change entry_set to have own independent function that does not rely on creating a new entry? and using entry_connect?
        -:  499:// TODO: Create entry_modify() function i.e. starts with args and just changes values, and adds forward references to existing entry. (does not create a new entry)
        -:  500:
        -:  501:// Testing function to look at everything in memory
        -:  502:#if TEST == 1
        -:  503:	void _inspect_state(){
        -:  504:		entry* cursor = current_state;
        -:  505:		while (cursor != NULL){
        -:  506:			printf(">>> %s (Is simple: %d) %p\n", cursor->key, cursor->is_simple, cursor);
        -:  507:			printf("Values: ");
        -:  508:			for (int i = 0; i < cursor->length; i++){
        -:  509:				element elem = cursor->values[i];
        -:  510:				if (elem.type == ENTRY){
        -:  511:					printf("%s", elem.entry->key);
        -:  512:				} else {
        -:  513:					printf("%d", elem.value);
        -:  514:				}
        -:  515:				printf(" ");
        -:  516:			}
        -:  517:			printf("\n");
        -:  518:
        -:  519:			printf("Backward links (%ld): ", cursor->backward_size);
        -:  520:
        -:  521:			for (int i = 0; i < cursor->backward_size; i++){
        -:  522:				entry* backward = cursor->backward[i];
        -:  523:				printf("%s %p", backward->key, backward);
        -:  524:				printf(" ");
        -:  525:			}
        -:  526:			printf("\n");
        -:  527:
        -:  528:			printf("Forward links (%ld): ", cursor->forward_size);
        -:  529:			
        -:  530:			for (int i = 0; i < cursor->forward_size; i++){
        -:  531:				entry* forward= cursor->forward[i];
        -:  532:				printf("%s %p", forward->key, forward);
        -:  533:				printf(" ");
        -:  534:			}
        -:  535:			printf("\n");
        -:  536:
        -:  537:			cursor = cursor->next;
        -:  538:		}
        -:  539:	}
        -:  540:#else
      704:  541:	void _inspect_state(){
      704:  542:		return;
        -:  543:	}
        -:  544:#endif
        -:  545:
        -:  546:// TODO: Change the need to handle array's forward and backward max -> refactor so functions with entry_ start only have to do with entry.
        -:  547:// void entry_remove_from_forward(entry* e, entry* target);
        -:  548:// void entry_remove_from_backward(entry* e, entry* target);
        -:  549:// void entry_remove_entry_from_values(entry* e, entry* target);
        -:  550:// void entry_replace_entry_from_values(entry* e, int target);
        -:  551:// void entry_replace_entry_from_backward(entry* e, int target);
        -:  552:// void entry_replace_entry_from_forward(entry* e, int target);
        -:  553:// Lots of functions but you can still keep the entries remove functions -> just use them in recursive functions for naked entry arrays.
        -:  554://! If methods were related to method you would need to write 6 functions -> inefficient, lots of repetitive code
        -:  555:// void entry_remove_from_forward(entry* e, entry* target){
        -:  556:// 	e->forward = _entries_remove(e->forward, &e->forward_size, target);
        -:  557:// }
        -:  558:// void entry_remove_from_backward(entry* e, entry* target){
        -:  559:// 	e->backward = _entries_remove(e->backward, &e->backward_size, target);
        -:  560:// }
        -:  561:// void entry_replace_entry_from_values(entry* e, entry* target, entry* replacement){
        -:  562:// 	e->values = _elements_replace(e->values, &e->length, target, replacement);
        -:  563:// }
        -:  564:// void entry_add_to_forward(entry* e, entry* target){
        -:  565:// 	 if (e->forward_size == e->forward_max){
        -:  566://         e->forward_max *= 2;
        -:  567://         e->forward = realloc(e->forward, e->forward_max);
        -:  568://     }
        -:  569:// 	e->forward[e->forward_size++] = target;
        -:  570:// }
        -:  571:
        -:  572:// void entry_replace_entry_from_backward(entry* e, int target);
        -:  573:// void entry_replace_entry_from_forward(entry* e, int target);
        -:  574:
        -:  575:
        -:  576:// Removes entry with address rm from an array
     8414:  577:entry** _entries_remove(entry** entries, size_t* entries_len, entry* rm){
        -:  578:	
        -:  579:	// printf("entry to remove is %s\n", rm->key);
        -:  580:
     8414:  581:	int idx = 0;
        -:  582:	// Grab index to remove
  2002590:  583:	for (; idx < *entries_len; idx++){
        -:  584:		// printf("%s ", entries[idx]->key);
  2002590:  585:		if (strcmp(entries[idx]->key, rm->key) == 0){
     8414:  586:			break;
        -:  587:		}
        -:  588:	}
        -:  589:
        -:  590:	// TESTING:
        -:  591:	// printf("***Viewing entries BEFORE removing***\n");
        -:  592:	// for (int i = 0; i < *entries_len; i++){
        -:  593:	// 	printf("%s, ", entries[i]->key);
        -:  594:	// }
        -:  595:	// printf("\n");
        -:  596:	// printf("entries length is: %ld\n", *entries_len);
        -:  597:
        -:  598:	// Copy everything beyond index to index position
     8414:  599:	if (*entries_len == 1){ //! Edge case causing segfault because we cannot realloc?
      214:  600:		*entries_len = *entries_len - 1;
        -:  601:		// printf("%p\n", entries);
      214:  602:		free(entries); 
      214:  603:		entries = NULL; //! Need to return null or you'll return pointer to garbage;
        -:  604:	} else {
        -:  605:		// printf("%ld %d\n", *entries_len, idx); //! Mixed test case -> why is b's backward entry size of 2? Shouldn't be any forward links to a though in mixed test case
     8200:  606:		memmove(entries+idx, entries+idx+1, (*entries_len-(idx+1))*sizeof(entry*));
     8200:  607:		*entries_len = *entries_len - 1;
     8200:  608:		entries = realloc(entries, (*entries_len)*sizeof(entry*));
        -:  609:	}
        -:  610:
        -:  611:
        -:  612:	
        -:  613:	// // // TESTING;
        -:  614:	// printf("***Viewing entries AFTER removing***\n");
        -:  615:	// for (int i = 0; i < *entries_len; i++){
        -:  616:	// 	printf("%s, ", entries[i]->key);
        -:  617:	// }
        -:  618:	// printf("\n");
        -:  619:
     8414:  620:	return entries;
        -:  621:}
        -:  622:
       48:  623:entry** _entries_replace(entry** entries, size_t* entries_len, entry* target, entry* replacement){
        -:  624:	
        -:  625:
        -:  626:	// Grab index to remove
       48:  627:	int idx = 0;
       64:  628:	for (; idx < *entries_len; idx++){
       64:  629:		if (strcmp(entries[idx]->key, target->key) == 0){
       48:  630:			break;
        -:  631:		}
        -:  632:	}
        -:  633:
        -:  634:	// memcpy(entries+idx, replacement, sizeof(entry*));
       48:  635:	entries[idx] = replacement;
       48:  636:	return entries;
        -:  637:}
        -:  638:
       48:  639:element* _elements_replace(element* elements, size_t* elements_len, entry* target, entry* replacement){
        -:  640:	// Grab index to remove
       48:  641:	int idx = 0;
       96:  642:	for (; idx < *elements_len; idx++){
        -:  643:		// if (elements[idx].type == ENTRY && elements[idx].entry == target){
       96:  644:		if (elements[idx].type == ENTRY && strcmp(elements[idx].entry->key, target->key) == 0){
       48:  645:			break;
        -:  646:		}
        -:  647:	}
        -:  648:	// printf("Target: %p, Replacement: %p\n", elements[idx].entry, replacement);
       48:  649:	elements[idx].entry = replacement;
        -:  650:	// printf("Target: %p, Replacement: %p\n", elements[idx].entry, replacement);
       48:  651:	return elements;
        -:  652:}
        -:  653:
        -:  654:
        -:  655:// makes a new entry take the place of an existing entry
        -:  656://! entry_set does not set entries back links to the right address -> may be to do with copying mechanism?
     4571:  657:void entry_set(entry* e, entry** current_state_ptr){
        -:  658:	// Search through current state and see if the entry with key is tehre
     4571:  659:	entry* existing = entry_get(e->key, current_state_ptr);
     4571:  660:	if (existing == NULL){
     4495:  661:		state_push(e, current_state_ptr); // TODO: Consider whether you should by default push or append?
        -:  662:	} else {
        -:  663:
        -:  664:		//! Fix the segfault error when you do b 2 d
        -:  665:		// printf("Setting general entry with key: %s\n", existing->key);
        -:  666:		// printf("Backward links (%ld): ", existing->backward_size);
        -:  667:
        -:  668:		// for (int i = 0; i < existing->backward_size; i++){
        -:  669:		// 	entry* backward = existing->backward[i];
        -:  670:		// 	printf("%s", backward->key);
        -:  671:		// 	printf(" ");
        -:  672:		// }
        -:  673:		// printf("\n");
        -:  674:
        -:  675:		// printf("Forward links (%ld): ", existing->forward_size);
        -:  676:		
        -:  677:		// for (int i = 0; i < existing->forward_size; i++){
        -:  678:		// 	entry* forward= existing->forward[i];
        -:  679:		// 	printf("%s", forward->key);
        -:  680:		// 	printf(" ");
        -:  681:		// }
        -:  682:		// printf("\n");
        -:  683:		// END test section
        -:  684:		
       76:  685:		_inspect_state();
        -:  686:
        -:  687:		// Remove all backward links to current entry
      108:  688:		for (int i = 0; i < existing->forward_size; i++){// TODO: Replace this with _rm_forward_link_to
       32:  689:			entry* forward = existing->forward[i];
       32:  690:			forward->backward = _entries_remove(forward->backward, &forward->backward_size, existing); 
        -:  691:		}
        -:  692:
        -:  693:		
        -:  694:
        -:  695:		// printf("Successfully removed exsiting forwad entries that point to new entry\n");
        -:  696:
        -:  697:		
        -:  698:		//! a->new b - Troublesome section here
        -:  699:		//! O(n^2) if you set the entries.
        -:  700:		// Make all existing back entries point forward to new replacement entry
        -:  701:		// printf("Existing: %p, Replacement: %p\n", existing, e);
      124:  702:		for (int i = 0; i < existing->backward_size; i++){
       48:  703:			entry* backward = existing->backward[i];
       48:  704:			backward->forward = _entries_replace(backward->forward, &backward->forward_size, existing, e);
       48:  705:			backward->values = _elements_replace(backward->values, &backward->length, existing, e);
        -:  706:		}
        -:  707:
       76:  708:		_inspect_state();
        -:  709:
        -:  710:		// printf("--------------\n");
        -:  711:
        -:  712:		// Make e take position of existing state
       76:  713:		entry* before = existing->prev;
       76:  714:		entry* after = existing->next;
        -:  715:
       76:  716:		e->next = after;
       76:  717:		e->prev = before;
        -:  718:
       76:  719:		if (before != NULL){
       64:  720:			before->next = e;
        -:  721:		} else {
        -:  722:			// current_state = e;
       12:  723:			*current_state_ptr = e;
        -:  724:		}
        -:  725:
       76:  726:		if (after != NULL){
       48:  727:			after->prev = e;
        -:  728:		}
        -:  729:		
        -:  730:		// Make new state have back references of previous state
       76:  731:		entry** backward_copy = calloc(existing->backward_size, sizeof(entry*));
       76:  732:		memcpy(backward_copy, existing->backward, existing->backward_size*(sizeof(entry*)));
       76:  733:		e->backward = backward_copy;
        -:  734:		// e->backward_max = existing->backward_max;
       76:  735:		e->backward_size = existing->backward_size;
       76:  736:		_inspect_state();
        -:  737:		
       76:  738:		entry_free(existing);
       76:  739:		_inspect_state();
        -:  740:	}
     4571:  741:}
        -:  742:
        -:  743:
        -:  744:
        -:  745:
        -:  746:
        -:  747:// Reverses and entry
        4:  748:void entry_reverse(entry* e){
        4:  749:	if (e->is_simple == false){
    #####:  750:		printf("Cannot reverse an entry that is not simple!\n");
    #####:  751:		return;
        -:  752:	}
        -:  753:
       12:  754:	for (int i = 0; i < e->length/2; i++){
        8:  755:		swap(e->values, i, e->length-1-i, sizeof(element));
        -:  756:	}
        -:  757:}
        -:  758:
        -:  759://! entry* get_all_forward_recursive(entry* e)
        -:  760:
        -:  761:// Appends entry to the entry array (not directly to entry->next), MUST reassign to return value due to pass by value
  4013884:  762:entry** _entries_append(entry** list, entry* e, int* list_size){
  4013884:  763:	*list_size = *list_size + 1;
  4013884:  764:	if (*list_size == 1){
    21220:  765:		list = calloc(1, sizeof(entry*));
        -:  766:	} else {
  3992664:  767:		list = realloc(list, (*list_size)*sizeof(entry*));
        -:  768:	}
  4013884:  769:	list[*list_size-1] = e;
  4013884:  770:	return list;
        -:  771:}
        -:  772:
    #####:  773:void entry_clear_visits(entry* current_state){
    #####:  774:	entry* cursor = current_state;
    #####:  775:	while (cursor != NULL){
    #####:  776:		cursor->has_visited = false;
    #####:  777:		cursor = cursor->next;
        -:  778:	}
    #####:  779:}
        -:  780:
        -:  781://! realloc() invalid pointer
        -:  782://! How to avoid adding the same node over and over again in DFS (same as the copying nodes question) -> check clone graph question on leetcode (but that only works for limited nodes, where each node has one value -> can't use array trick, must use hashmap here)
        -:  783://! example solution will be to add all elements to the array 
        -:  784://! Boss solution: Create own set/hashmap data structure that works with any input so you can perform traversals without repetiiton yet also do it in constant time (need to write own hash function though)
    12585:  785:entry** _get_forward_links(entry* e, int* size){
    12585:  786:	entry** forwards = NULL;
    12585:  787:	entry** next_forwards = NULL;
    12585:  788:	int next_size = 0;
        -:  789:
        -:  790:	// Base case - If the current entry has already been visited i.e. added to forwards list, don't add it again
    12585:  791:	e->has_visited = true;
        -:  792:
        -:  793:	// Add all forwards list 
  6007389:  794:	for (int i = 0; i < e->forward_size; i++){
  5994804:  795:		entry* forward_link = e->forward[i];
        -:  796:		
  5994804:  797:		if (forward_link->has_visited == true) continue;	
        -:  798:
        -:  799:		// Resize forwards and add link to end of list
    12420:  800:		forwards = _entries_append(forwards, forward_link, size);	//! Need to get the new forwards value because of pass by value unless you use triple pointer
        -:  801:	
        -:  802:		// DFS forward - Get array containing recursive (only if the entry is not marked as visited)
    12420:  803:		next_size = 0; //? next_size resetted for every iteration of the loop
    12420:  804:		next_forwards = _get_forward_links(forward_link, &next_size);
        -:  805:	
        -:  806:		// Attach fowards from recursive call to end of current list		
    12420:  807:		if (next_size > 0){
    12152:  808:			*size += next_size;
    12152:  809:			forwards = realloc(forwards, (*size)*sizeof(entry*));		
    12152:  810:			memcpy(forwards+*size-next_size, next_forwards, next_size*sizeof(entry*));
    12152:  811:			free(next_forwards);
        -:  812:		}
        -:  813:	}
        -:  814:	
    12585:  815:	return forwards;
        -:  816:}
        -:  817:
        -:  818:
        -:  819://! Calling array should free the array
        -:  820:// Returns array containing all forward_entries, with int telling the length of the entry array
      165:  821:entry** get_forward_links(entry* e, int* size){
      165:  822:	entry** forwards = _get_forward_links(e, size);
      165:  823:	e->has_visited = false;
    12585:  824:	for (int i = 0; i < *size; i++){
    12420:  825:		forwards[i]->has_visited = false;
        -:  826:	}	
      165:  827:	return forwards;
        -:  828:}
        -:  829:
     4184:  830:entry** _get_backward_links(entry* e, int* size){
        -:  831:	entry** backwards;
        -:  832:	entry** next_backwards;
     4184:  833:	int next_size = 0;
        -:  834:
        -:  835:	// Base case - If the current entry has already been visited i.e. added to forwards list, don't add it again
     4184:  836:	e->has_visited = true;
        -:  837:
        -:  838:	// Add all forwards list 
  2002348:  839:	for (int i = 0; i < e->backward_size; i++){
  1998164:  840:		entry* backward_link = e->backward[i];
        -:  841:		
  1998164:  842:		if (backward_link->has_visited == true) continue;	
        -:  843:
        -:  844:		// Resize forwards and add link to end of list
     4104:  845:		backwards = _entries_append(backwards, backward_link, size);	//! Need to get the new forwards value because of pass by value unless you use triple pointer
        -:  846:	
        -:  847:		// DFS forward - Get array containing recursive (only if the entry is not marked as visited)
     4104:  848:		next_size = 0; //? next_size resetted for every iteration of the loop
     4104:  849:		next_backwards = _get_backward_links(backward_link, &next_size);
        -:  850:	
        -:  851:		// Attach fowards from recursive call to end of current list		
     4104:  852:		if (next_size > 0){
       24:  853:			*size += next_size;
       24:  854:			backwards = realloc(backwards, (*size)*sizeof(entry*));		
       24:  855:			memcpy(backwards+*size-next_size, next_backwards, next_size*sizeof(entry*));
       24:  856:			free(next_backwards);
        -:  857:		}
        -:  858:	}
        -:  859:	
     4184:  860:	return backwards;
        -:  861:}
        -:  862:
       80:  863:entry** get_backward_links(entry* e, int* size){
       80:  864:	entry** backwards = _get_backward_links(e, size);
       80:  865:	e->has_visited = false;
     4184:  866:	for (int i = 0; i < *size; i++){
     4104:  867:		backwards[i]->has_visited = false;
        -:  868:	}
       80:  869:	return backwards;
        -:  870:}
        -:  871:
        -:  872:// the elements we want to compare are of type entry* but we put &(entry*) in the args so need to double dereference
    46580:  873:int entry_keycomp(const void* e1, const void* e2){
    46580:  874:	entry** entry_1 = (entry**) e1;
    46580:  875:	entry** entry_2 = (entry**) e2; 
        -:  876:	// printf("%s %s %d ", entry_1[0]->key, entry_2[0]->key, strcmp(entry_1[0]->key, entry_2[0]->key));
    46580:  877:	int result = strcmp(entry_1[0]->key, entry_2[0]->key);
    46580:  878:	return result;
        -:  879:}
        -:  880:
       81:  881:void entry_forward(entry* e){
       81:  882:	int size = 0;
       81:  883:	entry** forward_entries = get_forward_links(e, &size);	
        -:  884:	// printf("size: %d\n", size);
       81:  885:	qsort(forward_entries, size, sizeof(entry*), &entry_keycomp);
        -:  886:
        -:  887:	// TODO: Sort to lexicographical order;
       81:  888:	e->has_visited = false;
     4265:  889:	for (int i = 0; i < size; i++){
     4184:  890:		printf("%s ", forward_entries[i]->key);
        -:  891:	}
        -:  892:
       81:  893:	if (size == 0){
       17:  894:		printf("nil\n");
        -:  895:	} else {
       64:  896:		free(forward_entries);
       64:  897:		printf("\n");
        -:  898:	}
       81:  899:}
        -:  900:
        -:  901://! Memory reference issue, list entries can get the entries, but it is terminated by null byte
        -:  902:// TODO: Function is recursive -> keep adding backwards links to char list until no more backwards
        -:  903://? Does not return correct backward references.
       80:  904:void entry_backward(entry* e){
       80:  905:	int size = 0;
       80:  906:	entry** backward_entries = get_backward_links(e, &size);	
       80:  907:	qsort(backward_entries, size, sizeof(entry*), entry_keycomp);
        -:  908:	// Loop through all entries and reset their visited value;
        -:  909:
        -:  910:	// Sort to lexicographical order;
       80:  911:	e->has_visited = false;
     4184:  912:	for (int i = 0; i < size; i++){
     4104:  913:		printf("%s ", backward_entries[i]->key);
        -:  914:		// backward_entries[i]->has_visited = false;
        -:  915:	}
        -:  916:
       80:  917:	if (size == 0){
       20:  918:		printf("nil\n");
        -:  919:	} else {
       60:  920:		free(backward_entries);
       60:  921:		printf("\n");
        -:  922:	}
       80:  923:}
        -:  924:
       23:  925:void entry_type(entry* e){
       23:  926:	if (e->is_simple){
       14:  927:		printf("simple\n");
        -:  928:	} else {
        9:  929:		printf("general\n");
        -:  930:	}
       23:  931:}
        -:  932:
        -:  933://! Would this count as quadratic time? Ask about this, if so don't delete the back links
      200:  934:void _rm_forward_links_to(entry* e){
        -:  935:	// Remove each back link to e every for every forward link e has
     8532:  936:	for (int i = 0; i < e->forward_size; i++){
     8332:  937:		entry* forward_link = e->forward[i];
     8332:  938:		forward_link->backward = _entries_remove(forward_link->backward, &forward_link->backward_size, e);
        -:  939:	}
      200:  940:}
        -:  941:
      200:  942:void _rm_backward_links_to(entry* e){
        -:  943:	// Remove forward links to e for every back link e has
     200*:  944:	for (int i = 0; i < e->backward_size; i++){
    #####:  945:		entry* backward_link = e->backward[i];
    #####:  946:		backward_link->forward = _entries_remove(backward_link->forward, &backward_link->forward_size, e);
        -:  947:	}
      200:  948:}
        -:  949:
      572:  950:bool entry_candel(entry* e){
      572:  951:	return e->backward_size == 0;
        -:  952:}
        -:  953:
      200:  954:void entry_delete(entry* e, entry** current_state_ptr){
      200:  955:	_inspect_state();
        -:  956:
      200:  957:	if (!entry_candel(e)){
    #####:  958:		return;
        -:  959:	} else {
      200:  960:		_rm_forward_links_to(e);
      200:  961:		_rm_backward_links_to(e);
        -:  962:
      200:  963:		entry* before = e->prev;
      200:  964:		entry* after = e->next;
        -:  965:
        -:  966:		// Reset before and after links
      200:  967:		if (before != NULL){
      124:  968:			before->next = after;
        -:  969:		}
      200:  970:		if (after != NULL){
       56:  971:			after->prev = before;
        -:  972:		}
        -:  973:
        -:  974:		// Reset current state
      200:  975:		if ((*current_state_ptr)->key == e->key){
       76:  976:			*current_state_ptr = e->next;
        -:  977:		}	
        -:  978:
      200:  979:		entry_free(e);
      200:  980:		_inspect_state();
        -:  981:	}
        -:  982:}
        -:  983:
      220:  984:int element_compare(const void* e1, const void* e2){
      220:  985:	element* element_1 = (element*) e1;
      220:  986:	element* element_2 = (element*) e2;
      220:  987:	int result = element_1->value - element_2->value; 
      220:  988:	return result;
        -:  989:}
        -:  990:
        -:  991:// Use C library's sorting algos
        8:  992:void entry_sort(entry* e){
        8:  993:	qsort(e->values, e->length, sizeof(element), &element_compare); //? Seems like we don't need to add the & sign next to function to make it a function pointer?
        8:  994:}
        -:  995:
    #####:  996:void entry_unique(entry* e){
    #####:  997:	if (e->is_simple == false){
    #####:  998:		printf("Cannot make unique an entry that is not simple!\n");
        -:  999:	}
        -: 1000:
    #####: 1001:	element* new_values = calloc(e->length, sizeof(element));
    #####: 1002:	element* last_word = NULL; //! Set it to null or you'll get stack underflow error (last_word == NULl) does not work
    #####: 1003:	element* cursor = e->values;
        -: 1004:
    #####: 1005:	int new_size = 0;
    #####: 1006:	for (int i = 0; i < e->length; i++){
    #####: 1007:		if (last_word == NULL || element_compare(last_word, cursor) != 0){
    #####: 1008:			memcpy(new_values+new_size, cursor, sizeof(element));
    #####: 1009:			new_size++;
        -: 1010:		}
        -: 1011:
    #####: 1012:		last_word = cursor;
    #####: 1013:		cursor++;
        -: 1014:	}
    #####: 1015:	new_values = realloc(new_values, new_size*sizeof(element));
    #####: 1016:	free(e->values); //TODO: Effectively free these values
    #####: 1017:	e->length = new_size;
    #####: 1018:	e->values = new_values;
        -: 1019:
    #####: 1020:}
        -: 1021:
       85: 1022:void entry_pick(entry* e, int index){	
       85: 1023:	if (e->length == 0){
    #####: 1024:		printf("nil\n");
    #####: 1025:		return;
        -: 1026:	}
        -: 1027:	
       85: 1028:	if (index < 0 || index >= e->length){
       12: 1029:		printf("index out of range\n");
       12: 1030:		return;
        -: 1031:	}
        -: 1032:
        -: 1033:
       73: 1034:	element* elem = e->values+index;
        -: 1035:
        -: 1036:	
       73: 1037:	if (elem->type == INTEGER){
        -: 1038:		#if (TEST == 1)
        -: 1039:			printf("Value at index %d in entry with key %s is: %d\n", index, e->key, elem->value);
        -: 1040:		#else
       40: 1041:			printf("%d\n", elem->value);
        -: 1042:		#endif
        -: 1043:	} else {
        -: 1044:		#if (TEST == 1)
        -: 1045:			printf("Value at index %d in entry with key %s is: %s\n", index, e->key, elem->entry->key);
        -: 1046:		#else
       33: 1047:			printf("%s\n", elem->entry->key);
        -: 1048:		#endif
        -: 1049:	}
        -: 1050:
        -: 1051:	
        -: 1052:
        -: 1053:}
        -: 1054:
        -: 1055:// Extra O(n) operation to calculate local min, max, and sum.
    26792: 1056:void entry_recalcsmm(entry* e){
    26792: 1057:	int min = INT_MAX;
    26792: 1058:	int max = INT_MIN;
    26792: 1059:	int sum = 0;
        -: 1060:	// Search through entries to find new min new max
  8657283: 1061:	for (int i = 0; i < e->length; i++){
  8630491: 1062:		element* current_element = e->values+i;
  8630491: 1063:		if (current_element->type != ENTRY){
        -: 1064:			// Update sum, min, max
    31914: 1065:			if (current_element->value < min){
    26860: 1066:				min = current_element->value;
        -: 1067:			}
    31914: 1068:			if (current_element->value > max){
    27613: 1069:				max = current_element->value;
        -: 1070:			}
    31914: 1071:			sum += current_element->value;	
        -: 1072:		}
        -: 1073:	}	
    26792: 1074:	e->min = min;
    26792: 1075:	e->max = max;
    26792: 1076:	e->sum = sum;
        -: 1077:	// printf("%s: max: %d min: %d sum: %d ", e->key, e->max, e->min, e->sum);
        -: 1078:
    26792: 1079:}
        -: 1080:
        -: 1081:
        -: 1082:
       73: 1083:void entry_pluck(entry* e, int index){
        -: 1084:	// printf("%ld\n", e->length);
        -: 1085:
       73: 1086:	if (index < 0 || index >= e->length){
        8: 1087:		printf("index out of range\n");
        8: 1088:		return;
        -: 1089:	}	
        -: 1090:
       65: 1091:	if (e->length == 0){
    #####: 1092:		printf("nil\n");
    #####: 1093:		return;
        -: 1094:	}
        -: 1095:
       65: 1096:	entry_pick(e, index);
       65: 1097:	element* elem_to_remove = e->values+index;
       65: 1098:	item_type type = elem_to_remove->type;
        -: 1099:
        -: 1100:	// Remove backlinks to e for entries that link back to e due to e containing elem_to_remove
       65: 1101:	if (type == ENTRY){
       25: 1102:		entry* forward = elem_to_remove->entry;
       25: 1103:		forward->backward =_entries_remove(forward->backward, &forward->backward_size, e); // remove back link
       25: 1104:		e->forward = _entries_remove(e->forward, &e->forward_size, elem_to_remove->entry); // remove forwad link
        -: 1105:	}
        -: 1106:	
       65: 1107:	e->length--;
       65: 1108:	memmove(elem_to_remove, elem_to_remove+1, (e->length-index)*sizeof(element)); //! Address sanitizer issue -> use memmove instead?
       65: 1109:	e->values = realloc(e->values, e->length*sizeof(element));
       65: 1110:	if (type == INTEGER){
       40: 1111:		entry_recalcsmm(e);
        -: 1112:	}
        -: 1113:
       65: 1114:	update_is_simple(e);
        -: 1115:}
        -: 1116:
       16: 1117:void entry_pop(entry* e){
        -: 1118:	// You cannot have an index out of range error for pop -> always check for length first
       16: 1119:	if (e->length == 0){
    #####: 1120:		printf("nil\n");
    #####: 1121:		return;
        -: 1122:	}
       16: 1123:	entry_pluck(e, 0);
        -: 1124:}
        -: 1125:
    #####: 1126:void list_keys(entry** current_state_ptr){
    #####: 1127:	entry* cursor = *current_state_ptr;
        -: 1128:
    #####: 1129:	if (cursor == NULL){
    #####: 1130:		printf("no keys\n");
    #####: 1131:		return;
        -: 1132:	}
        -: 1133:
    #####: 1134:	while (cursor != NULL){
    #####: 1135:		printf("%s\n", cursor->key);
    #####: 1136:		cursor = cursor->next;
        -: 1137:	}
        -: 1138:}
        -: 1139:
      334: 1140:void list_entries(entry** current_state_ptr){
      334: 1141:	entry* cursor = *current_state_ptr;
        -: 1142:	// TEST = 1;
        -: 1143:	// _inspect_state();
        -: 1144:	// TEST = 0;
      334: 1145:	if (cursor == NULL){
       28: 1146:		printf("no entries\n");
       28: 1147:		return;
        -: 1148:	}
        -: 1149:
     1189: 1150:	while (cursor != NULL){
      883: 1151:		printf("%s ", cursor->key);
      883: 1152:		entry_tostring(cursor); //? Should this display the links as a letter or the elements in that next link?
      883: 1153:		cursor = cursor->next;
        -: 1154:	}
        -: 1155:	// _inspect_state();
        -: 1156:}
        -: 1157:
       48: 1158:void list_snapshots(snapshot** latest_snap_ptr){
       48: 1159:	snapshot* cursor = *latest_snap_ptr;
        -: 1160:
       48: 1161:	if (cursor == NULL){
    #####: 1162:		printf("no snapshots\n");
    #####: 1163:		return;
        -: 1164:	}
        -: 1165:
      140: 1166:	while (cursor != NULL){
       92: 1167:		printf("%d\n", cursor->id);
       92: 1168:		cursor = cursor->prev;
        -: 1169:	}
        -: 1170:}
        -: 1171:
      172: 1172:snapshot* snapshot_get(int id, snapshot** latest_snap_ptr){
      172: 1173:	snapshot* cursor = *latest_snap_ptr;
      284: 1174:	while (cursor != NULL){
      240: 1175:		if (id == cursor->id){
      128: 1176:			return cursor;
        -: 1177:		}
      112: 1178:		cursor = cursor->prev;
        -: 1179:	}
       44: 1180:	return NULL;
        -: 1181:}
        -: 1182:
        -: 1183:// Creates a copy of the entry inside e->copy_reference that links to all forward entries.
  2003300: 1184:entry* _entry_copy(entry* e){
        -: 1185:
        -: 1186:	// Return entry's copy if it has already been copied'
  2003300: 1187:	if (e->copy_reference != NULL){
  1998576: 1188:		return e->copy_reference;
        -: 1189:	}
        -: 1190:
        -: 1191:	// Store unique version of the values for copy
     4724: 1192:	entry* copy = calloc(1, sizeof(entry));
     4724: 1193:	element* copy_values = calloc(e->length, sizeof(element));
        -: 1194:
        -: 1195:	// Store copy of e's forward entries (new forward array)
     4724: 1196:	int forward_copies_size = 0;
     4724: 1197:	entry** forward_copies = NULL;
        -: 1198:	// entry** forward_copies = calloc(e->forward_size, sizeof(entry*)); //! mem leak
        -: 1199:
        -: 1200:	// Copy memory from e for the entry to copy, but clear forward/backward arrays for copies
     4724: 1201:	memcpy(copy, e, sizeof(entry));
     4724: 1202:	copy->values = NULL;
     4724: 1203:	copy->backward_size = 0;
     4724: 1204:	copy->forward_size = 0;
     4724: 1205:	copy->backward = NULL;
     4724: 1206:	copy->forward = NULL;
        -: 1207:	
        -: 1208:	// Iterate through all values and make links to copies of forward entries 
  2008668: 1209:	for (int i = 0; i < e->length; i++){
  2003944: 1210:		element* elem = e->values + i;
  2003944: 1211:		element* elem_copy = copy_values + i;
  2003944: 1212:		memcpy(elem_copy, elem, sizeof(element)); //? Copy values over by default, deal with entry case as exception
  2003944: 1213:		if (elem->type == ENTRY){
        -: 1214:			#if TEST == 1
        -: 1215:				printf("%s", elem->entry->key);
        -: 1216:			#endif
  1998680: 1217:			entry* forward_copy = _entry_copy(elem->entry); // TODO: Fix returning of copy reference, nvm it is working. just didn't read right?
        -: 1218:			
        -: 1219:			// Connect e to copy of forward link in both ways
        -: 1220:			// TODO: Check if we made a genuine copy of the forward and backward arrays
  1998680: 1221:			forward_copy->backward = _entries_append(forward_copy->backward, copy, (int*)&forward_copy->backward_size); //! 2 hours spent on figuring out that you should attach copy to back of new entry not old e (used memory address debuggin method)
  1998680: 1222:			forward_copies = _entries_append(forward_copies, forward_copy, (int*)&forward_copies_size);
  1998680: 1223:			elem_copy->type = ENTRY;
  1998680: 1224:			elem_copy->entry = forward_copy; 
        -: 1225:		} 
        -: 1226:		
        -: 1227:	}
        -: 1228:
     4724: 1229:	copy->values = copy_values;
     4724: 1230:	copy->forward = forward_copies;
     4724: 1231:	copy->forward_size = forward_copies_size;	
     4724: 1232:	e->copy_reference = copy;
        -: 1233:
        -: 1234:
     4724: 1235:	return copy;
        -: 1236:}
        -: 1237:
        -: 1238:
        -: 1239://? Could create pointer to last element and just append to that 
        -: 1240:// Sets the correct next and prev pointers for the snapshot to be appended.
      144: 1241:void snapshot_append(snapshot* snap, snapshot** latest_snap_ptr){
      144: 1242:	if (*latest_snap_ptr == NULL){
       64: 1243:		*latest_snap_ptr = snap;
        -: 1244:	} else {
       80: 1245:		(*latest_snap_ptr)->next = snap;
       80: 1246:		snap->prev = (*latest_snap_ptr);
       80: 1247:		(*latest_snap_ptr) = snap;
        -: 1248:	}
      144: 1249:}
        -: 1250:
        -: 1251://?! Are forward and backward entries of a certain entry always going to maintain the same index? probably not? e.g. triangle
      236: 1252:snapshot* snapshot_create(entry* entries, int id){
      236: 1253:	entry* cursor = entries;
      236: 1254:	entry* entries_copy = NULL;
      236: 1255:	entry* previous = NULL;
        -: 1256:
     4960: 1257:	while (cursor != NULL){
     4724: 1258:		entry* copy = cursor->copy_reference;
     4724: 1259:		if (copy == NULL){
     4620: 1260:			copy = _entry_copy(cursor); //! might have corrupted top size with poor management of entry_copy() -> old
        -: 1261:		}
        -: 1262:
        -: 1263:		// Link entry to previous entry in chain
     4724: 1264:		if (previous != NULL){
     4496: 1265:			previous->next = copy;
     4496: 1266:			copy->prev = previous;
        -: 1267:		} 
        -: 1268:	
        -: 1269:		// Ensure entries copy points to first copied entry;
     4724: 1270:		if (entries_copy == NULL){
      228: 1271:			entries_copy = copy;
        -: 1272:		}
        -: 1273:
     4724: 1274:		previous = copy;
     4724: 1275:		cursor = cursor->next;
        -: 1276:	}
        -: 1277:
        -: 1278:	// Set all elements' copy_reference to null after creating snapshot
      236: 1279:	cursor = entries;
     4960: 1280:	while (cursor != NULL){
        -: 1281:		// printf("%s ", cursor->key);
     4724: 1282:		cursor->copy_reference = NULL;
     4724: 1283:		cursor->has_visited = false;
     4724: 1284:		cursor = cursor->next;
        -: 1285:	}
        -: 1286:	// printf("\n");
        -: 1287:
      236: 1288:	snapshot* new_snapshot = calloc(1, sizeof(snapshot));
        -: 1289:	// printf("%p\n", entries_copy);
        -: 1290:	// printf("%s\n", entries_copy->key);
      236: 1291:	new_snapshot->entries = entries_copy;
      236: 1292:	new_snapshot->id = id;
        -: 1293:	// if (last_snapshot != NULL){
        -: 1294:	// 	new_snapshot->id = last_snapshot->id+1; //TODO: Check if this is the correct id naming system or if you should have global var tracker.
        -: 1295:	// } else {
        -: 1296:	// 	new_snapshot->id = 1;
      236: 1297:	return new_snapshot;
        -: 1298:}
        -: 1299:
        -: 1300:// Free up all the entries in the snapshot
      422: 1301:void snapshot_free(entry* entries){
        -: 1302:	
      422: 1303:	entry* cursor = entries;
      422: 1304:	entry* old = NULL;
     9441: 1305:	while (cursor != NULL){
     9019: 1306:		old = cursor;
     9019: 1307:		cursor = cursor->next; //! Make sure cursor points a allocated block of memory 
     9019: 1308:		entry_free(old);
        -: 1309:	}
      422: 1310:}
        -: 1311:
        -: 1312:
        -: 1313:
        -: 1314://! Bug: If you delete a snapsot when there is only one snapshots, subsequent snapshots added will not be found.
        -: 1315://? error handling done by the main function
      144: 1316:void snapshot_drop(snapshot* snap, snapshot** latest_snap_ptr){
      144: 1317:	snapshot* before = snap->prev;
      144: 1318:	snapshot* after = snap->next;
        -: 1319:
        -: 1320:	// Free up all the entries in the snapshot
        -: 1321:	#if (TEST == 1)
        -: 1322:		printf("Trying to free entries in the snapshot to be dropped\n");
        -: 1323:	#endif
      144: 1324:	snapshot_free(snap->entries); //! Segfault line
        -: 1325:	#if (TEST == 1)
        -: 1326:		printf("succesfully freed entries in the snapshot to be dropped\n");
        -: 1327:	#endif
        -: 1328:
        -: 1329:	// Get previous snapshot to point to next snapshot and vice versa
      144: 1330:	if (after != NULL){
       12: 1331:		after->prev = before;
        -: 1332:	}
        -: 1333:
      144: 1334:	if (before != NULL){
       72: 1335:		before->next = after;
        -: 1336:	}
        -: 1337:	
      144: 1338:	if (snap->id == (*latest_snap_ptr)->id){
      132: 1339:		*latest_snap_ptr = before;
        -: 1340:	} 
        -: 1341:	
        -: 1342:	// else {
        -: 1343:
        -: 1344:	// }
        -: 1345:	
        -: 1346:	// if (before == NULL){
        -: 1347:	// 	latest_snapshot = NULL;
        -: 1348:	// 	first_snapshot = after;
        -: 1349:	// 	if (first_snapshot == NULL){
        -: 1350:	// 		latest_snapshot = NULL;
        -: 1351:	// 	}
        -: 1352:	// } else if (snap == latest_snapshot) {
        -: 1353:	// 	latest_snapshot = snap->prev;
        -: 1354:	// 	before->next = NULL;
        -: 1355:	// } else {
        -: 1356:	// 	before->next = after;
        -: 1357:	// 	after->prev = before;
        -: 1358:	// }
        -: 1359:
        -: 1360:	// // Update first and last snapshot
        -: 1361:	// //! Last_snapshot needs to be null 
        -: 1362:
        -: 1363:	
        -: 1364:
        -: 1365:
      144: 1366:	free(snap);
        -: 1367:
      144: 1368:}
        -: 1369:
      186: 1370:void program_clear(entry** current_state_ptr, snapshot** latest_snap_ptr){
      186: 1371:	snapshot* cursor = *latest_snap_ptr; 
        -: 1372:	snapshot* old;
        -: 1373:
      186: 1374:	snapshot_free(*current_state_ptr); 
        -: 1375:
      278: 1376:	while (cursor != NULL){
       92: 1377:		old = cursor;
       92: 1378:		cursor = cursor->prev;
       92: 1379:		snapshot_drop(old, latest_snap_ptr);
        -: 1380:	}
      186: 1381:}
        -: 1382:
       24: 1383:void snapshot_rollback(snapshot* snap, entry** current_state_ptr, snapshot** latest_snap_ptr){
       24: 1384:	snapshot* cursor = *latest_snap_ptr; 
        -: 1385:	snapshot* old;
        -: 1386:
       24: 1387:	snapshot_free(*current_state_ptr);
        -: 1388:
        -: 1389:	// Got the snapshot we want (deleting snapshots along the way)
       40: 1390:	while (cursor != NULL){
       40: 1391:		if (cursor == snap){
       24: 1392:			break;
        -: 1393:		}
       16: 1394:		old = cursor;
       16: 1395:		cursor = cursor->prev;
       16: 1396:		snapshot_drop(old, latest_snap_ptr);
        -: 1397:	}
        -: 1398:
        -: 1399:	// Create copy of snapshot we want to rollback to
       24: 1400:	snapshot* snap_copy = snapshot_create(cursor->entries, 0); //! snapshot id does not matter here as we just want the entries
       24: 1401:	*current_state_ptr = snap_copy->entries;
       24: 1402:	free(snap_copy);
        -: 1403:	// Clear the current state (//TODO: Implement deep delete function alongside deep copy function)
       24: 1404:}
        -: 1405:
        -: 1406://! When you checkout to an entry and then drop that entry whilst you're in the snapshot -> you get junk values when you list entries.
       68: 1407:void snapshot_checkout(snapshot* snap, entry** current_state_ptr){
        -: 1408:	// Free current state
       68: 1409:	snapshot_free(*current_state_ptr);
       68: 1410:	snapshot* snap_copy = snapshot_create(snap->entries, 0);
       68: 1411:	*current_state_ptr = snap_copy->entries;
       68: 1412:	free(snap_copy); //? don't need id for copy of snapshot
       68: 1413:}
        -: 1414:
      144: 1415:snapshot* snapshot_save(int id, entry** current_state_ptr, snapshot** latest_snap_ptr){
      144: 1416:	snapshot* new_snapshot = snapshot_create(*current_state_ptr, id);  //! Snapshots are not freed?
      144: 1417:	snapshot_append(new_snapshot, latest_snap_ptr);
      144: 1418:	return new_snapshot;
        -: 1419:}
        -: 1420:
    #####: 1421:int snapshot_size(snapshot* snap){
    #####: 1422:	int size = 0;
    #####: 1423:	entry* cursor = snap->entries;
    #####: 1424:	while (cursor != NULL){
    #####: 1425:		cursor = cursor->next;
    #####: 1426:		size++;
        -: 1427:	}
    #####: 1428:	return size;
        -: 1429:}
        -: 1430:
        -: 1431:// Returns false if a key with back entries is found in snapshots or current state
      164: 1432:bool can_purge(char* key, entry** current_state_ptr, snapshot** latest_snap_ptr){
      164: 1433:	entry* original_state = *current_state_ptr;
        -: 1434:	entry* to_delete;
      164: 1435:	snapshot* snap = *latest_snap_ptr;
        -: 1436:
      280: 1437:	while (snap != NULL){
      144: 1438:		*current_state_ptr = snap->entries;
      144: 1439:		to_delete = entry_get(key, current_state_ptr);
      144: 1440:		if (to_delete != NULL && !entry_candel(to_delete)){
       28: 1441:			*current_state_ptr = original_state;
       28: 1442:			return false;
        -: 1443:		}
      116: 1444:		snap->entries = *current_state_ptr; //? Make snapshot possess correct starting entries upon deletion
      116: 1445:		snap = snap->prev;
        -: 1446:	}
        -: 1447:
      136: 1448:	*current_state_ptr = original_state;
      136: 1449:	to_delete = entry_get(key, current_state_ptr);
      136: 1450:	if (to_delete != NULL && !entry_candel(to_delete)){
        8: 1451:		return false;
        -: 1452:	}
        -: 1453:
      128: 1454:	return true;
        -: 1455:}
        -: 1456:
       64: 1457:void purge(char* key, entry** current_state_ptr, snapshot** latest_snap_ptr){
        -: 1458:
       64: 1459:	if (!can_purge(key, current_state_ptr, latest_snap_ptr)){
    #####: 1460:		printf("not permitted\n");
    #####: 1461:		return;
        -: 1462:	}
        -: 1463:	
       64: 1464:	entry* original_state = *current_state_ptr;
       64: 1465:	entry* to_delete = NULL;
        -: 1466:	
        -: 1467:	// Find key in snapshots and delete
       64: 1468:	snapshot* snap = *latest_snap_ptr;
      120: 1469:	while (snap != NULL){
       56: 1470:		*current_state_ptr = snap->entries;
       56: 1471:		to_delete = entry_get(key, current_state_ptr);
        -: 1472:
        -: 1473:		#if TEST == 1
        -: 1474:			printf("deleting entries in snapshot %d\n", snap->id);
        -: 1475:		#endif 
       56: 1476:		if (to_delete != NULL){
       52: 1477:			entry_delete(to_delete, current_state_ptr);
        -: 1478:		}
       56: 1479:		snap->entries = *current_state_ptr; //? Make snapshot possess correct starting entries upon deletion
       56: 1480:		snap = snap->prev;
        -: 1481:	}
        -: 1482:
        -: 1483:	// Restore original state after purging
        -: 1484:	// Find key in current database and delete
       64: 1485:	*current_state_ptr = original_state;
       64: 1486:	to_delete = entry_get(key, current_state_ptr);
       64: 1487:	if (to_delete != NULL){
       48: 1488:		entry_delete(to_delete, current_state_ptr);
        -: 1489:	} 
        -: 1490:
        -: 1491:}
        -: 1492:
      186: 1493:int main(void) {
        -: 1494:
      186: 1495:	char line[MAX_LINE];	
      186: 1496:	int next_snap_id = 1;
        -: 1497:
      186: 1498:	entry* current_state = NULL; 
      186: 1499:	snapshot* latest_snapshot = NULL;
        -: 1500:
    28279: 1501:	while (true) {
    28465: 1502:		printf("> ");
        -: 1503:	
    28465: 1504:		if (NULL == fgets(line, MAX_LINE, stdin)) {
        8: 1505:			printf("\n");
        8: 1506:			program_clear(&current_state, &latest_snapshot);
        8: 1507:			command_bye();
        8: 1508:			return 0;
        -: 1509:		}
        -: 1510:
        -: 1511:		// Process multiple arguments to the command line
        -: 1512:		# if (PRINT_COMMAND == 1)
        -: 1513:			printf("%s", line);
        -: 1514:		#endif
        -: 1515:
    28457: 1516:		char* word = strtok(line, " \n\r"); 
    28457: 1517:		char** args = calloc(MAX_LINE, sizeof(char*));
    28457: 1518:		size_t args_size = 0;
  2093142: 1519:		while (word != NULL) {
  2064685: 1520:			args[args_size] = word;
  2064685: 1521:			args_size++;
  2064685: 1522:			word = strtok(NULL, " \n\r"); //! Tells the function to use the last string that was inputted into strtok -> returns NULL when it reaches \0 byte in the string
        -: 1523:		}
        -: 1524:	
    28457: 1525:		char* command_type = args[0];
    28457: 1526:		if (command_type == NULL){
    #####: 1527:			free(args);
    #####: 1528:			continue;
        -: 1529:		}
        -: 1530:		
    28457: 1531:		if (strcasecmp(command_type, "SET") == 0){
     4615: 1532:			entry* e = entry_create(args+1, args_size-1, &current_state); 
     4615: 1533:			if (e != NULL){
     4571: 1534:				entry_set(e, &current_state);
     4571: 1535:				MSG_OK
        -: 1536:			}
    23842: 1537:		} else if (strcasecmp(command_type, "PUSH") == 0){
      153: 1538:			entry* e = entry_get(args[1], &current_state);
      153: 1539:			if (e == NULL) {
        4: 1540:				MSG_NOKEY
        -: 1541:			} else {
      149: 1542:				if (entry_push(e, args+2, args_size-2, &current_state)){
      117: 1543:    				MSG_OK
        -: 1544:                } 
        -: 1545:			}
    23689: 1546:		} else if (strcasecmp(command_type, "APPEND") == 0){
    22088: 1547:			entry* e = entry_get(args[1], &current_state); //? +1 so that we don't include the command in the arguments used to build the entry
    22088: 1548:			if (e == NULL){
        4: 1549:				MSG_NOKEY
        -: 1550:			} else {
    22084: 1551:                if (entry_append(e, args+2, args_size-2, &current_state)){
    22064: 1552:    				MSG_OK
        -: 1553:                }
        -: 1554:			}
     1601: 1555:		} else if (strcasecmp(command_type, "GET") == 0){
       44: 1556:			entry* e = entry_get(args[1], &current_state);
       44: 1557:			if (e == NULL) {
        4: 1558:				MSG_NOKEY
        -: 1559:			} else {
       40: 1560:				entry_tostring(e);
        -: 1561:			}
     1557: 1562:		} else if (strcasecmp(command_type, "DEL") == 0){
      152: 1563:			entry* e = entry_get(args[1], &current_state);
      152: 1564:			if (e == NULL){
       20: 1565:				MSG_NOKEY
      132: 1566:			} else if (!entry_candel(e)){
       32: 1567:				MSG_NOPERM
        -: 1568:			} else {
      100: 1569:				entry_delete(e, &current_state);
      100: 1570:				MSG_OK
        -: 1571:			}
        -: 1572:			// fwrapper_entry(e, &entry_delete);
     1405: 1573:		} else if (strcasecmp(command_type, "MIN") == 0){
        8: 1574:			entry* e = entry_get(args[1], &current_state);
        8: 1575:			if (e == NULL) {
    #####: 1576:				MSG_NOKEY
        -: 1577:			} else {
        8: 1578:				entry_min(e);
        -: 1579:			}			
     1397: 1580:		} else if (strcasecmp(command_type, "MAX") == 0){
       12: 1581:			entry* e = entry_get(args[1], &current_state);
       12: 1582:			if (e == NULL) {
    #####: 1583:				MSG_NOKEY
        -: 1584:			} else {
       12: 1585:				entry_max(e);
        -: 1586:			}	
     1385: 1587:		} else if (strcasecmp(command_type, "SUM") == 0){
       36: 1588:			entry* e = entry_get(args[1], &current_state); // TODO: Add local sum, max, len so you don't have to sum degrees.
       36: 1589:			if (e == NULL){
    #####: 1590:				MSG_NOKEY
        -: 1591:			} else {
       36: 1592:				entry_sum(e);
        -: 1593:			}
     1349: 1594:		} else if (strcasecmp(command_type, "LEN") == 0){
       28: 1595:			entry* e = entry_get(args[1], &current_state);
       28: 1596:			if (e == NULL) {
    #####: 1597:				MSG_NOKEY
        -: 1598:			} else {
       28: 1599:				entry_len(e);
        -: 1600:			}
     1321: 1601:		} else if (strcasecmp(command_type, "SORT") == 0){
        8: 1602:			entry* e = entry_get(args[1], &current_state);
        8: 1603:            if (e == NULL){
    #####: 1604:                MSG_NOKEY
        -: 1605:            } else{
        8: 1606:                if (e->is_simple == false){
    #####: 1607:			    	printf("simple entry only\n");
        -: 1608:			    } else {
        8: 1609:                    entry_sort(e);
        8: 1610:                    MSG_OK
        -: 1611:                }  
        -: 1612:            }
     1313: 1613:		} else if (strcasecmp(command_type, "REV") == 0){
        8: 1614:			entry* e = entry_get(args[1], &current_state);
        8: 1615:			if (e == NULL){
    #####: 1616:                MSG_NOKEY
        -: 1617:            } else{
        8: 1618:                if (e->is_simple == false){
        4: 1619:			    	printf("simple entry only\n");
        -: 1620:			    } else {
        4: 1621:                    entry_reverse(e);
        4: 1622:                    MSG_OK
        -: 1623:                }  
        -: 1624:            }
     1305: 1625:		} else if (strcasecmp(command_type, "UNIQ") == 0){
    #####: 1626:			entry* e = entry_get(args[1], &current_state); //TODO: add input verification and also checking that entry exists
    #####: 1627:			if (e == NULL){
    #####: 1628:                MSG_NOKEY
        -: 1629:            } else{
    #####: 1630:                if (e->is_simple == false){
    #####: 1631:			    	printf("simple entry only\n");
        -: 1632:			    } else {
    #####: 1633:                    entry_unique(e);
    #####: 1634:                    MSG_OK
        -: 1635:                }  
        -: 1636:            }
     1305: 1637:		} else if (strcasecmp(command_type, "PLUCK") == 0){
       57: 1638:			entry* e = entry_get(args[1], &current_state);
       57: 1639:			if (e == NULL) {
    #####: 1640:				MSG_NOKEY
        -: 1641:			} else {
       57: 1642:				if (!string_isnumeric(args[2])){
    #####: 1643:					printf("Cannot pluck an index that is not numeric!\n");
        -: 1644:				} else {
       57: 1645:					int index = atoi(args[2])-1;
       57: 1646:					entry_pluck(e, index);	
        -: 1647:				}	
        -: 1648:			}
     1248: 1649:		} else if (strcasecmp(command_type, "PICK") == 0){
       28: 1650:			entry* e = entry_get(args[1], &current_state);
       28: 1651:			if (e == NULL) {
        8: 1652:				MSG_NOKEY
        -: 1653:			} else {
       20: 1654:				if (!string_isnumeric(args[2])){
    #####: 1655:					printf("Cannot pick an index that is not numeric!\n");
        -: 1656:				} else {
       20: 1657:					int index = atoi(args[2])-1;
       20: 1658:					entry_pick(e, index);	
        -: 1659:				}
        -: 1660:			}
     1220: 1661:		} else if (strcasecmp(command_type, "POP") == 0){
       20: 1662:			entry* e = entry_get(args[1], &current_state);
       20: 1663:			if (e == NULL){
        4: 1664:				MSG_NOKEY
        -: 1665:			} else {
       16: 1666:				entry_pop(e);
        -: 1667:			}
     1200: 1668:		} else if (strcasecmp(command_type, "FORWARD") == 0){
       97: 1669:			entry* e = entry_get(args[1], &current_state);
       97: 1670:			if (e == NULL){	
       16: 1671:				MSG_NOKEY  
        -: 1672:			} else {
       81: 1673:				entry_forward(e);
        -: 1674:			}
     1103: 1675:		} else if (strcasecmp(command_type, "BACKWARD") == 0){
       92: 1676:			entry* e = entry_get(args[1], &current_state);
       92: 1677:			if (e == NULL){	
       12: 1678:				MSG_NOKEY  
        -: 1679:			} else {
       80: 1680:				entry_backward(e);
        -: 1681:			}
     1011: 1682:		} else if (strcasecmp(command_type, "PURGE") == 0){
      100: 1683:			char* key = args[1];
      100: 1684:			if (!can_purge(key, &current_state, &latest_snapshot)){
       36: 1685:				MSG_NOPERM
        -: 1686:			} else {
       64: 1687:				purge(key, &current_state, &latest_snapshot);
       64: 1688:				MSG_OK
        -: 1689:			}
      911: 1690:		}  else if (strcasecmp(command_type, "TYPE") == 0){
       23: 1691:			entry* e = entry_get(args[1], &current_state);
       23: 1692:			if (e == NULL) {
    #####: 1693:				MSG_NOKEY //TODO: Use function pointers (create wrapper function) to call any functions that use the get entry method.
        -: 1694:			} else {
       23: 1695:				entry_type(e);
        -: 1696:			}
      888: 1697:		} else if (strcasecmp(command_type, "LIST") == 0){
      382: 1698:			char* option = args[1];
      382: 1699:			if (strcasecmp(option, "KEYS") == 0){
    #####: 1700:				list_keys(&current_state);
      382: 1701:			} else if (strcasecmp(option, "ENTRIES") == 0){
      334: 1702:				list_entries(&current_state);
       48: 1703:			} else if (strcasecmp(option, "SNAPSHOTS") == 0){
       48: 1704:				list_snapshots(&latest_snapshot);
        -: 1705:			} 
      506: 1706:		} else if (strcasecmp(command_type, "SNAPSHOT") == 0){
      144: 1707:		 	snapshot* snap = snapshot_save(next_snap_id++, &current_state, &latest_snapshot);
      144: 1708:			printf("saved as snapshot %d\n", snap->id);
      362: 1709:		} else if (strcasecmp(command_type, "DROP") == 0){ //! Segfaults
       40: 1710:			if (!string_isnumeric(args[1])){
    #####: 1711:				printf("You must provide a valid ID for a snapshot!\n");
        -: 1712:			} else {
       40: 1713:				int id = atoi(args[1]);
       40: 1714:				snapshot* snap = snapshot_get(id, &latest_snapshot);
       40: 1715:				if (snap == NULL){
        4: 1716:					MSG_NOSNAP
        -: 1717:				} else {
       36: 1718:					snapshot_drop(snap, &latest_snapshot);
       36: 1719:					MSG_OK
        -: 1720:				}
        -: 1721:			}
      322: 1722:		} else if (strcasecmp(command_type, "ROLLBACK") == 0){ //! Segfaults
       36: 1723:			if (!string_isnumeric(args[1])){
    #####: 1724:				printf("You must provide a valid ID for a snapshot!\n");
        -: 1725:			} else {
       36: 1726:				int id = atoi(args[1]);
       36: 1727:				snapshot* snap = snapshot_get(id, &latest_snapshot);
       36: 1728:				if (snap == NULL){
       12: 1729:					MSG_NOSNAP
        -: 1730:				} else {
       24: 1731:					snapshot_rollback(snap, &current_state, &latest_snapshot);
       24: 1732:					MSG_OK
        -: 1733:				}
        -: 1734:			}
      286: 1735:		} else if (strcasecmp(command_type, "CHECKOUT") == 0){
      104: 1736:			if (!string_isnumeric(args[1])){
        8: 1737:				printf("You must provide a valid ID for a snapshot!\n");
        -: 1738:			} else {
       96: 1739:				int id = atoi(args[1]);
       96: 1740:				snapshot* snap = snapshot_get(id, &latest_snapshot);
       96: 1741:				if (snap == NULL){
       28: 1742:					MSG_NOSNAP
        -: 1743:				} else {
       68: 1744:					snapshot_checkout(snap, &current_state);
       68: 1745:					MSG_OK
        -: 1746:				}
        -: 1747:			}
      182: 1748:		} else if (strcasecmp(command_type, "HELP") == 0){
    #####: 1749:		 	command_help();
      182: 1750:		} else if (strcasecmp(command_type, "BYE") == 0){
      178: 1751:			command_bye();
      178: 1752:			program_clear(&current_state, &latest_snapshot); 
      178: 1753:			free(args);
      178: 1754:			return 0;
        -: 1755:		}
        -: 1756:
    28279: 1757:		printf("\n");
    28279: 1758:		free(args);
        -: 1759:  	}
        -: 1760:
        -: 1761:	return 0;
        -: 1762:}
