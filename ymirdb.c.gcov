        -:    0:Source:ymirdb.c
        -:    0:Graph:ymirdb.gcno
        -:    0:Data:ymirdb.gcda
        -:    0:Runs:760
        -:    0:Source is newer than graph
        -:    1:/**
        -:    2: * comp2017 - assignment 2
        -:    3: * Tim Yang
        -:    4: * yyan0195
        -:    5: */
        -:    6:
        -:    7:#include <stdio.h>
        -:    8:#include <stdlib.h>
        -:    9:#include <string.h>
        -:   10:#include <strings.h>
        -:   11:#include <stdbool.h>
        -:   12:#include <ctype.h>
        -:   13:#include <limits.h>
        -:   14:#include "ymirdb.h"
        -:   15:#define MSG_NOKEY printf("no such key\n");
        -:   16:#define MSG_NOSNAP printf("no such snapshot\n");
        -:   17:#define MSG_NOPERM printf("not permitted\n");
        -:   18:#define MSG_OK printf("ok\n");
        -:   19:
        -:   20:// Helper function to update is_simple status of entry
        -:   21:void update_is_simple(entry* e){
        -:   22:	if (e->forward_size > 0){
   171367:   23:		e->is_simple = false;
   171367:   24:	} else {
   171133:   25:		e->is_simple = true;
        -:   26:	}
      234:   27:}
        -:   28:
   171367:   29:// Swaps two elements in idx1 and idx2 in any array
        -:   30:void swap(void* a1, int idx1, int idx2, size_t size_each_elem){
        -:   31:	void* temp = calloc(1, size_each_elem);
      167:   32:	memcpy(temp, a1+idx1*size_each_elem, size_each_elem); 
      167:   33:	memcpy(a1+idx1*size_each_elem, a1+idx2*size_each_elem, size_each_elem);
      167:   34:	memcpy(a1+idx2*size_each_elem, temp, size_each_elem);
      167:   35:	free(temp);
      167:   36:}
      167:   37:
      167:   38:// Bye command prints bye before exiting
        -:   39:void command_bye() {
        -:   40:	printf("bye\n");
      760:   41:}
      760:   42:
      760:   43:// Prints the help string for the help command
        -:   44:void command_help() {
        -:   45:	printf("%s", HELP);
        7:   46:}
        7:   47:
        7:   48:// Returns if a string follows a numeric format (positive/negative int)
        -:   49:bool string_isnumeric(char* string){
        -:   50:	char* cursor = string;
  5882422:   51:	if (*cursor == '-'){
  5882422:   52:		cursor++;
  5882422:   53:	}
      258:   54:
        -:   55:	while (*cursor != '\0'){
        -:   56:		if (!isdigit(*cursor)){
  6837389:   57:			return false;
  6562232:   58:		}
  5607265:   59:		cursor++;
        -:   60:	}
   954967:   61:	return true;
        -:   62:}
   275157:   63:
        -:   64:// Prints out content of entry in a string format
        -:   65:void entry_tostring(entry* e){
        -:   66:	char* string = calloc(e->length*2, sizeof(char));
     3151:   67:	printf("[");
     3151:   68:	for (int i = 0; i < e->length; i++){
     3151:   69:		element* current_element = (e->values+i);
    27980:   70:		if (current_element->type == ENTRY){
    24829:   71:			printf("%s", current_element->entry->key);
    24829:   72:		} else {
     2040:   73:			printf("%d", current_element->value);
        -:   74:		}
    22789:   75:		
        -:   76:		if (i != e->length-1){
        -:   77:			printf(" ");
    24829:   78:		}
    21693:   79:	}
        -:   80:	printf("]\n");
        -:   81:	free(string);
     3151:   82:}	
     3151:   83:
     3151:   84:
        -:   85:// Returns an entry given the key and the current state's last entry
        -:   86:entry* entry_get(char* key, entry** current_state_ptr){
        -:   87:
  5906090:   88:	// Perform linear search over current database
        -:   89:	entry* cursor = *current_state_ptr;
        -:   90:	while (cursor != NULL){
  5906090:   91:		if (strcmp(key, cursor->key) == 0){
3529715969:   92:			return cursor;
3529592389:   93:		}
  5782510:   94:		cursor = cursor->next;
        -:   95:	}
3523809879:   96:	return NULL;
        -:   97:}
   123580:   98:
        -:   99:// Connect e to forward entry (forward -> e and e -> forward)
        -:  100:void entry_connect(entry* e, entry* forward){
        -:  101:
  5606077:  102:	// Resize the memory 
        -:  103:	e->forward_size++;
        -:  104:	e->forward = realloc(e->forward, (e->forward_size)*sizeof(entry*));
  5606077:  105:	forward->backward_size++;
  5606077:  106:	forward->backward = realloc(forward->backward, 
  5606077:  107:								(forward->backward_size)*sizeof(entry*));
  5606077:  108:
  5606077:  109:	// Add forward reference and backward references to the end of the list
        -:  110:	e->forward[e->forward_size-1] = forward;
        -:  111:	forward->backward[forward->backward_size-1] = e;
  5606077:  112:
  5606077:  113:}
        -:  114:
  5606077:  115:// Creates values array for entry from cmdline args and the current state
        -:  116:element* elements_create(char** args, size_t args_size, entry** current_state_ptr){
        -:  117:	element* elements = calloc(args_size, sizeof(element)); 
   294327:  118:	for (int i = 0; i < args_size; i++){
   294327:  119:		element* current_elem = elements + i;
  6037845:  120:		char* current_arg = args[i];
  5743518:  121:		if (string_isnumeric(current_arg)){
  5743518:  122:			current_elem->type = INTEGER;		
  5743518:  123:			current_elem->value = atoi(current_arg);
   137199:  124:		} else {
   137199:  125:			current_elem->type = ENTRY;
        -:  126:			entry* forward_link = entry_get(current_arg, current_state_ptr);
  5606319:  127:			current_elem->entry = forward_link;
  5606319:  128:		}
  5606319:  129:	}
        -:  130:	return elements;
        -:  131:}
   294327:  132:
        -:  133:// Returns if a key is a valid key that is alphabetical and of valid length
        -:  134:bool key_isvalid(char* key){
        -:  135:	if (!isalpha(*key) || strlen(key) > 15) return false;
   123227:  136:	return true;
   123227:  137:}
   123182:  138:
        -:  139:// Creates an entry from args, connects entry to all relevant forward links 
        -:  140:entry* entry_create(char** args, size_t args_size, entry** current_state_ptr){
        -:  141:
   123228:  142:	// Perform error checking
        -:  143:	if (args_size <= 1){
        -:  144:		printf("Cannot create entry with no key or with a key but has no values\n");
   123228:  145:		return NULL;
        1:  146:	}
        1:  147:
        -:  148:	if (!key_isvalid(args[0])){
        -:  149:		MSG_NOPERM
   123227:  150:		return NULL;
       45:  151:	}
       45:  152:
        -:  153:	// Initialise empty entry
        -:  154:	char* key = args[0];
        -:  155:	entry* e = (entry *)calloc(1, sizeof(entry)); 
   123182:  156:	e->is_simple = true;
   123182:  157:	e->has_visited = false;
   123182:  158:	e->copy_reference = NULL;
   123182:  159:
   123182:  160:	// Check if entry contains links to other keys & keys exist & no loop to self
        -:  161:	for (int i = 1; i < args_size; i++){
        -:  162:		char* arg = args[i];
   261038:  163:		if (string_isnumeric(arg) == false){
   137933:  164:			e->is_simple = false;
   137933:  165:			entry* forward_link = entry_get(arg, current_state_ptr);
      924:  166:			
      924:  167:			if (strcmp(key, arg) == 0){
        -:  168:				MSG_NOPERM;
      924:  169:				entry_free(e);
       33:  170:				return NULL;
       33:  171:			} else if (forward_link == NULL){
       33:  172:				MSG_NOKEY
      891:  173:				entry_free(e);
       44:  174:				return NULL;
       44:  175:			}  
       44:  176:
        -:  177:
        -:  178:			// Connect elements if forward link is valid (handles adding to )
        -:  179:			entry_connect(e, forward_link);
        -:  180:		}
      847:  181:	}
        -:  182:
        -:  183:	// Create copy of string in args for entry
        -:  184:	memcpy(e->key, key, strlen(key)+1);
        -:  185:
   123105:  186:	// Set elements for entry
        -:  187:	e->values = elements_create(args+1, args_size-1, current_state_ptr);
        -:  188:	e->length = args_size-1;
   123105:  189:
   123105:  190:	// Set max, min, sum
        -:  191:	entry_recalcsmm(e);
        -:  192:
   123105:  193:	return e;
        -:  194:}
   123105:  195:
        -:  196:// Adds the entry to the database state (current_state)
        -:  197:void state_push(entry* e, entry** current_state_ptr){
        -:  198:	if (*current_state_ptr == NULL){
   122829:  199:		*current_state_ptr = e;
   122829:  200:	} else {
      686:  201:		// Add the entry to stack (current_state)
        -:  202:		entry* old_state = *current_state_ptr;
        -:  203:		*current_state_ptr = e;
   122143:  204:		(*current_state_ptr)->next = old_state;
   122143:  205:		old_state->prev = *current_state_ptr;
   122143:  206:	}
   122143:  207:}
        -:  208:
   122829:  209:// O(n) returns true if appended/pushed are valid -> prints errors.
        -:  210:bool _entry_values_change_is_valid(entry* e, size_t len, element* elements){
        -:  211:    // Check none of the elements pushed result in cycle or non-existant key
   171222:  212:    for (int i = 0; i < len; i++){
        -:  213:        element* current_element = elements+i;
  5776719:  214:        if (current_element->type == ENTRY){
  5605640:  215:            entry* forward_link = current_element->entry;
  5605640:  216:            if (forward_link == NULL){
  5605406:  217:                MSG_NOKEY
  5605406:  218:                return false;
       88:  219:            } else if (strcmp(forward_link->key, e->key) == 0){
       88:  220:                MSG_NOPERM
  5605318:  221:                return false;
       55:  222:            }
       55:  223:        }
        -:  224:    }
        -:  225:    return true;
        -:  226:}
   171079:  227:
        -:  228:// Appends values to an entry's values array, returns false if failed
        -:  229:bool entry_append(entry* e, char** args, size_t args_size, 
        -:  230:entry** current_state_ptr){
   170754:  231:	// Create array of elements to attach to the entry
        -:  232:	element* elements = elements_create(args, args_size, current_state_ptr);
        -:  233:    
   170754:  234:    if (!_entry_values_change_is_valid(e, args_size, elements)){
        -:  235:        free(elements);
   170754:  236:        return false;
       55:  237:    }
       55:  238:    
        -:  239:	int old_length = e->length;
        -:  240:	e->length = e->length + args_size;
   170699:  241:	e->values = realloc(e->values,	(e->length)*sizeof(element)); 
   170699:  242:	memcpy(e->values+old_length, elements, sizeof(element)*args_size);
   170699:  243:
   170699:  244:	for (int i = 0; i < args_size; i++){
        -:  245:		element* current_element = elements+i;
  5775560:  246:		if (current_element->type == ENTRY){
  5604861:  247:			entry* forward_link = current_element->entry;
  5604861:  248:			entry_connect(e, forward_link);
  5604795:  249:		} 
  5604795:  250:	}	
        -:  251:
        -:  252:	free(elements);
        -:  253:	entry_recalcsmm(e);
   170699:  254:    update_is_simple(e);
   170699:  255:	return true;
   170699:  256:}
   170699:  257:
        -:  258:// Reverses an array
        -:  259:void _reverse_array(void* array, int length, size_t size){
        -:  260:	for (int i = 0; i < length/2; i++){
      380:  261:		swap(array, i, length-i-1, size);
      525:  262:	}
      145:  263:}
        -:  264:
      380:  265:// Pushes values to an entry's values array, returns false if failed
        -:  266:bool entry_push(entry* e, char** args, size_t args_size, entry** current_state_ptr){
        -:  267:	// Create array of elements to attach to the entry
      468:  268:	element* elements = elements_create(args, args_size, current_state_ptr);
        -:  269:
      468:  270:    if (!_entry_values_change_is_valid(e, args_size, elements)){
        -:  271:        free(elements);
      468:  272:        return false;
       88:  273:    }
       88:  274:
        -:  275:	// Reverse elements insert a copy of that array to the front of e's values
        -:  276:    _reverse_array((void*)elements, (int)args_size, sizeof(element));
        -:  277:	e->length = e->length + args_size;
      380:  278:	e->values = realloc(e->values,	(e->length)*sizeof(element)); 
      380:  279:	memmove(e->values+args_size, e->values, sizeof(element)*(e->length-args_size));
      380:  280:	memcpy(e->values, elements, sizeof(element)*args_size);
      380:  281:
      380:  282:	// Connect all of our inserted elements to e (if they are general entries)
        -:  283:	for (int i = 0; i < args_size; i++){
        -:  284:		element* current_element = elements+i;
      983:  285:		if (current_element->type == ENTRY){
      603:  286:			entry* forward_link = current_element->entry;
      603:  287:			entry_connect(e, forward_link);
      435:  288:			e->is_simple = false;
      435:  289:		} 
      435:  290:	}	
        -:  291:
        -:  292:	// Remove the local elements array, recalculate e's sum, max, len, type
        -:  293:	free(elements); 
        -:  294:	entry_recalcsmm(e);
      380:  295:	update_is_simple(e);
      380:  296:    return true;
      380:  297:}
      380:  298:
        -:  299:// Prints out the minimum value for an entry
        -:  300:void entry_min(entry* e){
        -:  301:
      132:  302:	// Get all forward links the current entry
        -:  303:	int min = e->min;
        -:  304:	int forward_size = 0;
      132:  305:	entry** forwards  = get_forward_links(e, &forward_size);
      132:  306:
      132:  307:	// Compare e's own min with its forward link's mins
        -:  308:	for (int i = 0; i < forward_size; i++){
        -:  309:		if (forwards[i]->min < min){
   231297:  310:			min = forwards[i]->min;
   231165:  311:		}
       77:  312:	}
        -:  313:
        -:  314:	printf("%d\n", min);
        -:  315:
      132:  316:	if (forward_size > 0){
        -:  317:		free(forwards);
      132:  318:	}
       88:  319:
        -:  320:}
        -:  321:
      132:  322:// Prints out the maximum value for an entry
        -:  323:void entry_max(entry* e){
        -:  324:
      132:  325:	// Get all forward links the current entry
        -:  326:	int max = e->max;
        -:  327:	int forward_size = 0;
      132:  328:	entry** forwards  = get_forward_links(e, &forward_size);
      132:  329:	
      132:  330:	// Compare e's own max with its forward link's maxes
        -:  331:	for (int i = 0; i < forward_size; i++){
        -:  332:		if (forwards[i]->max > max){
   121385:  333:			max = forwards[i]->max;
   121253:  334:		}
   121011:  335:	}
        -:  336:	
        -:  337:	printf("%d\n", max);
        -:  338:
      132:  339:	if (forward_size > 0){
        -:  340:		free(forwards);
      132:  341:	}
       88:  342:}
        -:  343:
      132:  344:// Helper function entry_sum -> calculates forward sum of e + caches sum
        -:  345:int _calculate_sum(entry* e){
        -:  346:	if (e->has_visited){
   110734:  347:		return e->sum_forward;
   110734:  348:	}
      264:  349:	
        -:  350:	// Compute sum from e's sum and sum of its forwards
        -:  351:	int sum = e->sum;
        -:  352:	for (int i = 0; i < e->forward_size; i++){
   110470:  353:		sum += _calculate_sum(e->forward[i]);
   221064:  354:	}
   110594:  355:
        -:  356:	// Cache result so visits to this entry does not result in recomputation
        -:  357:	e->sum_forward = sum;
        -:  358:	e->has_visited = true;
   110470:  359:	return sum;
   110470:  360:}
   110470:  361:
        -:  362:
        -:  363:// Prints out the sum of an entry
        -:  364:void entry_sum(entry* e){
        -:  365:
      140:  366:	// Get e's forward links so we can clear the helper function's effects
        -:  367:	int forward_size = 0;
        -:  368:	entry** forwards  = get_forward_links(e, &forward_size);
      140:  369:	int sum = _calculate_sum(e);
      140:  370:	
      140:  371:	// Get all of e's unique forward links and clear 	
        -:  372:	e->has_visited = false;
        -:  373:	for (int i = 0; i < forward_size; i++){
      140:  374:		forwards[i]->has_visited = false;
   110470:  375:		forwards[i]->sum_forward = 0;
   110330:  376:	}
   110330:  377:	
        -:  378:	// Free memory for forwards array
        -:  379:	if (forward_size > 0){
        -:  380:		free(forwards);
      140:  381:	}
      110:  382:	
        -:  383:	printf("%d\n", sum);
        -:  384:}
      140:  385:
      140:  386:// Helper function to calculate length for entries
        -:  387:int _calculate_len(entry* e){
        -:  388:	if (e->has_visited){
      921:  389:		return e->len_forward;
      921:  390:	}
      308:  391:	
        -:  392:	int len = e->length - e->forward_size;
        -:  393:	for (int i = 0; i < e->forward_size; i++){
      613:  394:		len += _calculate_len(e->forward[i]);
     1328:  395:	}
      715:  396:
        -:  397:	e->len_forward = len;
        -:  398:	e->has_visited = true;
      613:  399:	return len;
      613:  400:}
      613:  401:
        -:  402:// Private method used by entry_len to get length of a general entry
        -:  403:int entry_len(entry* e){
        -:  404:	
      206:  405:	// Get forward uniques first so we can clear has_visited later
        -:  406:	int forward_size = 0;
        -:  407:	entry** forwards  = get_forward_links(e, &forward_size);
      206:  408:	int len = _calculate_len(e);
      206:  409:	
      206:  410:	// Get all of e's unique forward links and clear forward_visited
        -:  411:	e->has_visited = false;
        -:  412:	for (int i = 0; i < forward_size; i++){
      206:  413:		forwards[i]->has_visited = false;
      613:  414:		forwards[i]->len_forward = 0;
      407:  415:	}
      407:  416:	
        -:  417:	// Free memory for forwards array
        -:  418:	if (forward_size > 0){
        -:  419:		free(forwards);
      206:  420:	}
      110:  421:	
        -:  422:	printf("%d\n", len);
        -:  423:	
      206:  424:	return len;
        -:  425:}
      206:  426:
        -:  427:// Frees an entry and all its associated arrays
        -:  428:void entry_free(entry* e){	
        -:  429:	// Free all values pointed to by e
  1137916:  430:	if (e->values != NULL) free(e->values);
        -:  431:	if (e->forward != NULL) free(e->forward);
  1137916:  432:	if (e->backward != NULL) free(e->backward);
  1137916:  433:	if (e->copy_reference != NULL) free(e->copy_reference);
  1137916:  434:	free(e);
 1137916*:  435:}
  1137916:  436:
  1137916:  437:// Removes entry with address rm from an array
        -:  438:entry** _entries_remove(entry** entries, size_t* entries_len, entry* rm){
        -:  439:
    23493:  440:	int idx = 0;
        -:  441:
    23493:  442:	// Grab index to remove
        -:  443:	for (; idx < *entries_len; idx++){
        -:  444:		if (strcmp(entries[idx]->key, rm->key) == 0){
    23779:  445:			break;
    23779:  446:		}
    23493:  447:	}
        -:  448:
        -:  449:	// Copy everything beyond index to index position
        -:  450:	if (*entries_len == 1){ 
        -:  451:		*entries_len = *entries_len - 1;
    23493:  452:		free(entries); 
      807:  453:		entries = NULL;
      807:  454:	} else {
      807:  455:		memmove(entries+idx, entries+idx+1, 
        -:  456:				(*entries_len-(idx+1))*sizeof(entry*));
    22686:  457:		*entries_len = *entries_len - 1;
    22686:  458:		entries = realloc(entries, (*entries_len)*sizeof(entry*));
    22686:  459:	}
    22686:  460:
        -:  461:	return entries;
        -:  462:}
    23493:  463:
        -:  464:// Helper function that replaces a target in entries array with replacement
        -:  465:entry** _entries_replace(entry** entries, size_t* entries_len, entry* target, 
        -:  466:entry* replacement){
      209:  467:	
        -:  468:	// Grab index to remove
        -:  469:	int idx = 0;
        -:  470:	for (; idx < *entries_len; idx++){
      209:  471:		if (strcmp(entries[idx]->key, target->key) == 0){
      286:  472:			break;
      286:  473:		}
      209:  474:	}
        -:  475:
        -:  476:	entries[idx] = replacement;
        -:  477:	return entries;
      209:  478:}
      209:  479:
        -:  480:// Helper function that replaces target in elements array with replacement
        -:  481:element* _elements_replace(element* elements, size_t* elements_len, 
        -:  482:entry* target, entry* replacement){
      209:  483:	// Grab index to remove
        -:  484:	int idx = 0;
        -:  485:	for (; idx < *elements_len; idx++){
      209:  486:		if (elements[idx].type == ENTRY && strcmp(elements[idx].entry->key, 
      528:  487:			target->key) == 0){
      528:  488:			break;
      286:  489:		}
      209:  490:	}
        -:  491:
        -:  492:	elements[idx].entry = replacement;
        -:  493:	return elements;
      209:  494:}
      209:  495:
        -:  496:
        -:  497:// makes a new entry take the place of an existing entry
        -:  498:void entry_set(entry* e, entry** current_state_ptr){
        -:  499:
   123105:  500:	// Search through current state and see if the entry with key is tehre
        -:  501:	entry* existing = entry_get(e->key, current_state_ptr);
        -:  502:	if (existing == NULL){
   123105:  503:		state_push(e, current_state_ptr); 
   123105:  504:	} else {
   122829:  505:
        -:  506:		_rm_forward_links_to(existing);
        -:  507:
      276:  508:		// Make all existing back entries point forward to new replacement entry
        -:  509:		for (int i = 0; i < existing->backward_size; i++){
        -:  510:			entry* backward = existing->backward[i];
      485:  511:			backward->forward = _entries_replace(backward->forward, 
      209:  512:									&backward->forward_size, existing, e);
      209:  513:			backward->values = _elements_replace(backward->values, 
        -:  514:									&backward->length, existing, e);
      209:  515:		}
        -:  516:
        -:  517:		// Make e take position of existing state
        -:  518:		entry* before = existing->prev;
        -:  519:		entry* after = existing->next;
      276:  520:
      276:  521:		e->next = after;
        -:  522:		e->prev = before;
      276:  523:
      276:  524:		if (before != NULL){
        -:  525:			before->next = e;
      276:  526:		} else {
      242:  527:			*current_state_ptr = e;
        -:  528:		}
       34:  529:
        -:  530:		if (after != NULL){
        -:  531:			after->prev = e;
      276:  532:		}
      187:  533:		
        -:  534:		// Make new state have back references of previous state
        -:  535:		entry** backward_copy = calloc(existing->backward_size, sizeof(entry*));
        -:  536:		memcpy(backward_copy, existing->backward, 
      276:  537:				existing->backward_size*(sizeof(entry*)));
      276:  538:		e->backward = backward_copy;
      276:  539:		e->backward_size = existing->backward_size;
      276:  540:
      276:  541:		entry_free(existing);
        -:  542:	}
      276:  543:}
        -:  544:
   123105:  545:// Reverses and entry
        -:  546:void entry_reverse(entry* e){
        -:  547:	if (e->is_simple == false){
       11:  548:		printf("Cannot reverse an entry that is not simple!\n");
       11:  549:		return;
    #####:  550:	}
    #####:  551:
        -:  552:	for (int i = 0; i < e->length/2; i++){
        -:  553:		swap(e->values, i, e->length-1-i, sizeof(element));
       33:  554:	}
       22:  555:}
        -:  556:
        -:  557:// Appends entry to the entry array called list
        -:  558:entry** _entries_append(entry** list, entry* e, int* list_size){
        -:  559:	*list_size = *list_size + 1;
   727921:  560:	if (*list_size == 1){
   727921:  561:		list = calloc(1, sizeof(entry*));
   727921:  562:	} else {
   694377:  563:		list = realloc(list, (*list_size)*sizeof(entry*));
        -:  564:	}
    33544:  565:	list[*list_size-1] = e;
        -:  566:	return list;
   727921:  567:}
   727921:  568:
        -:  569:// Helper function: Visits all forward links only once to get all forwards in list
        -:  570:entry** _get_forward_links(entry* e, int* size){
        -:  571:	entry** forwards = NULL;
   585519:  572:	entry** next_forwards = NULL;
   585519:  573:	int next_size = 0;
   585519:  574:
   585519:  575:	// If the current entry has been visited/added to list, don't add it again
        -:  576:	e->has_visited = true;
        -:  577:
   585519:  578:	// Add all forwards list 
        -:  579:	for (int i = 0; i < e->forward_size; i++){
        -:  580:		entry* forward_link = e->forward[i];
 17621989:  581:		
 17036470:  582:		// If the current entry has been visited/added to list, don't add again
        -:  583:		if (forward_link->has_visited == true) continue;	
        -:  584:
 17036470:  585:		// Resize forwards and add link to end of list
        -:  586:		forwards = _entries_append(forwards, forward_link, size);	
        -:  587:	
   584674:  588:		// DFS forward - Get array containing recursive 
        -:  589:		next_size = 0; 
        -:  590:		next_forwards = _get_forward_links(forward_link, &next_size);
   584674:  591:	
   584674:  592:		// Attach fowards from recursive call to end of current list		
        -:  593:		if (next_size > 0){
        -:  594:			*size += next_size;
   584674:  595:			forwards = realloc(forwards, (*size)*sizeof(entry*));		
   583544:  596:			memcpy(forwards+*size-next_size, next_forwards, 
   583544:  597:					next_size*sizeof(entry*));
   583544:  598:			free(next_forwards);
        -:  599:		}
   583544:  600:	}
        -:  601:	
        -:  602:	return forwards;
        -:  603:}
   585519:  604:
        -:  605:// Returns array containing all forward_entries of an element e.
        -:  606:entry** get_forward_links(entry* e, int* size){
        -:  607:	entry** forwards = _get_forward_links(e, size);
      845:  608:	e->has_visited = false;
      845:  609:	for (int i = 0; i < *size; i++){
      845:  610:		forwards[i]->has_visited = false;
   585519:  611:	}	
   584674:  612:	return forwards;
        -:  613:}
      845:  614:
        -:  615:// Helper function: Visits all back links only once to get all back links in list
        -:  616:entry** _get_backward_links(entry* e, int* size){
        -:  617:	entry** backwards = NULL;
   143504:  618:	entry** next_backwards = NULL;
   143504:  619:	int next_size = 0;
   143504:  620:
   143504:  621:	// If the current entry has been visited/added to list, don't add it again
        -:  622:	e->has_visited = true;
        -:  623:
   143504:  624:	// Add all forwards list 
        -:  625:	for (int i = 0; i < e->backward_size; i++){
        -:  626:		entry* backward_link = e->backward[i];
 16715494:  627:		
 16571990:  628:		// If the current entry has been visited/added to list, don't add it again
        -:  629:		if (backward_link->has_visited == true) continue;	
        -:  630:
 16571990:  631:		// Resize forwards and add link to end of list
        -:  632:		backwards = _entries_append(backwards, backward_link, size);	
        -:  633:	
   143247:  634:		// DFS forward - Get array containing recursive 
        -:  635:		next_size = 0; 
        -:  636:		next_backwards = _get_backward_links(backward_link, &next_size);
   143247:  637:	
   143247:  638:		// Attach fowards from recursive call to end of current list		
        -:  639:		if (next_size > 0){
        -:  640:			*size += next_size;
   143247:  641:			backwards = realloc(backwards, (*size)*sizeof(entry*));		
   110044:  642:			memcpy(backwards+*size-next_size, next_backwards, 
   110044:  643:					next_size*sizeof(entry*));
   110044:  644:			free(next_backwards);
        -:  645:		}
   110044:  646:	}
        -:  647:	
        -:  648:	return backwards;
        -:  649:}
   143504:  650:
        -:  651:// Returns all backward links (recursive) for e, clears all cache variables.
        -:  652:entry** get_backward_links(entry* e, int* size){
        -:  653:	entry** backwards = _get_backward_links(e, size);
      257:  654:	e->has_visited = false;
      257:  655:	for (int i = 0; i < *size; i++){
      257:  656:		backwards[i]->has_visited = false;
   143504:  657:	}
   143247:  658:	return backwards;
        -:  659:}
      257:  660:
        -:  661:// Comparator used by sorting algorithm to sort entry order for forwards/bacl
        -:  662:int entry_keycomp(const void* e1, const void* e2){
        -:  663:	entry** entry_1 = (entry**) e1;
  1920494:  664:	entry** entry_2 = (entry**) e2; 
  1920494:  665:	int result = strcmp(entry_1[0]->key, entry_2[0]->key);
  1920494:  666:	return result;
  1920494:  667:}
  1920494:  668:
        -:  669:// Prints out all forward entries that e has (recursive search)
        -:  670:void entry_forward(entry* e){
        -:  671:	int size = 0;
      235:  672:	entry** forward_entries = get_forward_links(e, &size);	
      235:  673:	qsort(forward_entries, size, sizeof(entry*), &entry_keycomp);
      235:  674:
      235:  675:	if (size == 0){
        -:  676:		printf("nil\n");
      235:  677:		return;
       44:  678:	} else {
       44:  679:		for (int i = 0; i < size-1; i++){
        -:  680:			printf("%s, ", forward_entries[i]->key);
   121519:  681:		}
   121328:  682:		printf("%s\n", forward_entries[size-1]->key);
        -:  683:		free(forward_entries);
      191:  684:	} 	
      191:  685:}
        -:  686:
        -:  687:// Prints out all backward entries that e has (recursive search)
        -:  688:void entry_backward(entry* e){
        -:  689:
      257:  690:	// Retrieve backward all of e's backward entries using helper function
        -:  691:	int size = 0;
        -:  692:	entry** backward_entries = get_backward_links(e, &size);	
      257:  693:	
      257:  694:	// Sort to lexicographical order;
        -:  695:	qsort(backward_entries, size, sizeof(entry*), entry_keycomp);
        -:  696:
      257:  697:	// Print output
        -:  698:	if (size == 0){
        -:  699:		printf("nil\n");
      257:  700:		return;
       55:  701:	} else {
       55:  702:		for (int i = 0; i < size-1; i++){
        -:  703:			printf("%s, ", backward_entries[i]->key);
   143247:  704:		}
   143045:  705:		printf("%s\n", backward_entries[size-1]->key);
        -:  706:		free(backward_entries);
      202:  707:	}
      202:  708:}
        -:  709:
        -:  710:// Prints out whether an entry is simple or general
        -:  711:void entry_type(entry* e){
        -:  712:	if (e->is_simple){
       55:  713:		printf("simple\n");
       55:  714:	} else {
       33:  715:		printf("general\n");
        -:  716:	}
       22:  717:}
        -:  718:
       55:  719:// Remove forward entries' back links to the current entry in worst (O(n^2))
        -:  720:void _rm_forward_links_to(entry* e){
        -:  721:	// Remove each back link to e every for every forward link e has
     1134:  722:	for (int i = 0; i < e->forward_size; i++){
        -:  723:		entry* forward_link = e->forward[i];
    24495:  724:		forward_link->backward = _entries_remove(forward_link->backward, 
    23361:  725:										&forward_link->backward_size, e);
    23361:  726:	}
        -:  727:}
        -:  728:
     1134:  729:// Returns true if an entry is allowed to be deleted
        -:  730:bool entry_candel(entry* e){
        -:  731:	return e->backward_size == 0;
     2457:  732:}
     2457:  733:
        -:  734:// Deletes an entry from the current state (not snapshots)
        -:  735:void entry_delete(entry* e, entry** current_state_ptr){
        -:  736:
      858:  737:	if (!entry_candel(e)){
        -:  738:		return;
      858:  739:	} else {
    #####:  740:		_rm_forward_links_to(e);
        -:  741:
      858:  742:		entry* before = e->prev;
        -:  743:		entry* after = e->next;
      858:  744:
      858:  745:		// Reset before and after links
        -:  746:		if (before != NULL){
        -:  747:			before->next = after;
      858:  748:		}
      642:  749:		if (after != NULL){
        -:  750:			after->prev = before;
      858:  751:		}
      187:  752:
        -:  753:		// Reset current state
        -:  754:		if ((*current_state_ptr)->key == e->key){
        -:  755:			*current_state_ptr = e->next;
      858:  756:		}	
      216:  757:
        -:  758:		entry_free(e);
        -:  759:	}
      858:  760:}
        -:  761:
        -:  762:// Elements are the same if their values are the same (only for simple entries)
        -:  763:int element_compare(const void* e1, const void* e2){
        -:  764:	element* element_1 = (element*) e1;
      702:  765:	element* element_2 = (element*) e2;
      702:  766:	int result = element_1->value - element_2->value; 
      702:  767:	return result;
      702:  768:}
      702:  769:
        -:  770:// Use C library's sorting algos
        -:  771:void entry_sort(entry* e){
        -:  772:	qsort(e->values, e->length, sizeof(element), &element_compare); 
       37:  773:}
       37:  774:
       37:  775:// Create a new array and iterate through array adding adjacently unique entries
        -:  776:void entry_unique(entry* e){
        -:  777:	if (e->is_simple == false){
       23:  778:		printf("Cannot make unique an entry that is not simple!\n");
       23:  779:	}
    #####:  780:
        -:  781:	element* new_values = calloc(e->length, sizeof(element));
        -:  782:	element* last_word = NULL; 
       23:  783:	element* cursor = e->values;
       23:  784:
       23:  785:	int new_size = 0;
        -:  786:	for (int i = 0; i < e->length; i++){
       23:  787:		if (last_word == NULL || element_compare(last_word, cursor) != 0){
      138:  788:			memcpy(new_values+new_size, cursor, sizeof(element));
      115:  789:			new_size++;
       82:  790:		}
       82:  791:
        -:  792:		last_word = cursor;
        -:  793:		cursor++;
      115:  794:	}
      115:  795:
        -:  796:	// Shrink values array to required size for new_values
        -:  797:	new_values = realloc(new_values, new_size*sizeof(element));
        -:  798:	free(e->values); 
       23:  799:	e->length = new_size;
       23:  800:	e->values = new_values;
       23:  801:}
       23:  802:
       23:  803:// Print out a value at a specified index within an entry
        -:  804:void entry_pick(entry* e, int index){	
        -:  805:	
      343:  806:	if (index < 0 || index >= e->length){
        -:  807:		printf("index out of range\n");
      343:  808:		return;
       33:  809:	}
       33:  810:
        -:  811:	element* elem = e->values+index;
        -:  812:
      310:  813:	if (elem->type == INTEGER){
        -:  814:		printf("%d\n", elem->value);
      310:  815:	} else {
      222:  816:		printf("%s\n", elem->entry->key);
        -:  817:	}
       88:  818:}
        -:  819:
        -:  820:// Extra O(n) operation to calculate local min, max, and sum.
        -:  821:void entry_recalcsmm(entry* e){
        -:  822:	int min = INT_MAX;
   294406:  823:	int max = INT_MIN;
   294406:  824:	int sum = 0;
   294406:  825:
   294406:  826:	// Search through entries to find new min new max
        -:  827:	for (int i = 0; i < e->length; i++){
        -:  828:		element* current_element = e->values+i;
 24360902:  829:		if (current_element->type != ENTRY){
 24066496:  830:
 24066496:  831:			// Update sum, min, max
        -:  832:			if (current_element->value < min){
        -:  833:				min = current_element->value;
   310144:  834:			}
   294673:  835:			if (current_element->value > max){
        -:  836:				max = current_element->value;
   310144:  837:			}
   297713:  838:			sum += current_element->value;	
        -:  839:		}
   310144:  840:	}	
        -:  841:	e->min = min;
        -:  842:	e->max = max;
   294406:  843:	e->sum = sum;
   294406:  844:
   294406:  845:}
        -:  846:
   294406:  847:// Removes value at index and updates back/forward links if ENTRY is removed
        -:  848:void entry_pluck(entry* e, int index){
        -:  849:
      332:  850:	if (index < 0 || index >= e->length){
        -:  851:		printf("index out of range\n");
      332:  852:		return;
       44:  853:	}	
       44:  854:
        -:  855:	entry_pick(e, index);
        -:  856:	element* elem_to_remove = e->values+index;
      288:  857:	item_type type = elem_to_remove->type;
      288:  858:
      288:  859:	// Remove backlinks to e for entries that link back to e 
        -:  860:	if (type == ENTRY){
        -:  861:		entry* forward = elem_to_remove->entry;
      288:  862:		// remove back link
       66:  863:		forward->backward =_entries_remove(forward->backward,
        -:  864:											&forward->backward_size, e);
       66:  865:		// remove forwad link	 
        -:  866:		e->forward = _entries_remove(e->forward, &e->forward_size, 
        -:  867:									elem_to_remove->entry); 
       66:  868:	}
       66:  869:	
        -:  870:	// Shrink the values array and minimise memory use
        -:  871:	e->length--;
        -:  872:	memmove(elem_to_remove, elem_to_remove+1, (e->length-index)*sizeof(element)); 
      288:  873:	e->values = realloc(e->values, e->length*sizeof(element));
      288:  874:	if (type == INTEGER){
      288:  875:		entry_recalcsmm(e);
      288:  876:	}
      222:  877:
        -:  878:	update_is_simple(e);
        -:  879:}
      288:  880:
        -:  881:
        -:  882:// Pluck the first index of an entry for pop command if e is non-empty
        -:  883:void entry_pop(entry* e){
        -:  884:
      134:  885:	// Check we have non-empty entry before popping
        -:  886:	if (e->length == 0){
        -:  887:		printf("nil\n");
      134:  888:		return;
       11:  889:	}
       11:  890:	entry_pluck(e, 0);
        -:  891:}
      123:  892:
        -:  893:// List all keys for the current state by iterating through all keys
        -:  894:void list_keys(entry** current_state_ptr){
        -:  895:	entry* cursor = *current_state_ptr;
       33:  896:
       33:  897:	if (cursor == NULL){
        -:  898:		printf("no keys\n");
       33:  899:		return;
       11:  900:	}
       11:  901:
        -:  902:	while (cursor != NULL){
        -:  903:		printf("%s\n", cursor->key);
       55:  904:		cursor = cursor->next;
       33:  905:	}
       33:  906:}
        -:  907:
        -:  908:// List all keys for current state by iterating all entries and their keys
        -:  909:void list_entries(entry** current_state_ptr){
        -:  910:	entry* cursor = *current_state_ptr;
     1151:  911:
     1151:  912:	if (cursor == NULL){
        -:  913:		printf("no entries\n");
     1151:  914:		return;
      106:  915:	}
      106:  916:
        -:  917:	while (cursor != NULL){
        -:  918:		printf("%s ", cursor->key);
     4025:  919:		entry_tostring(cursor); 
     2980:  920:		cursor = cursor->next;
     2980:  921:	}
     2980:  922:
        -:  923:}
        -:  924:
        -:  925:// List all snapshots in the current data base if there are snapshots
        -:  926:void list_snapshots(snapshot** latest_snap_ptr){
        -:  927:	snapshot* cursor = *latest_snap_ptr;
      180:  928:
      180:  929:	if (cursor == NULL){
        -:  930:		printf("no snapshots\n");
      180:  931:		return;
       11:  932:	}
       11:  933:
        -:  934:	while (cursor != NULL){
        -:  935:		printf("%d\n", cursor->id);
      481:  936:		cursor = cursor->prev;
      312:  937:	}
      312:  938:}
        -:  939:
        -:  940:// Gets a snapshot by its id in the current database
        -:  941:snapshot* snapshot_get(int id, snapshot** latest_snap_ptr){
        -:  942:	snapshot* cursor = *latest_snap_ptr;
      685:  943:	while (cursor != NULL){
      685:  944:		if (id == cursor->id){
     1298:  945:			return cursor;
     1150:  946:		}
      537:  947:		cursor = cursor->prev;
        -:  948:	}
      613:  949:	return NULL;
        -:  950:}
      148:  951:
        -:  952:// Sets the correct next and prev pointers for the snapshot to be appended.
        -:  953:void snapshot_append(snapshot* snap, snapshot** latest_snap_ptr){
        -:  954:	if (*latest_snap_ptr == NULL){
        -:  955:		*latest_snap_ptr = snap;
        -:  956:	} else {
      606:  957:		(*latest_snap_ptr)->next = snap;
      606:  958:		snap->prev = (*latest_snap_ptr);
      246:  959:		(*latest_snap_ptr) = snap;
        -:  960:	}
      360:  961:}
      360:  962:
      360:  963:// Creates copy for new snapshot
        -:  964:entry* entry_copy_local_values(entry* e){
      606:  965:	entry* copy = calloc(1, sizeof(entry));	
        -:  966:	memcpy(copy, e, sizeof(entry));
        -:  967:	
  1014734:  968:	// Copy old backward array
  1014734:  969:	entry** old_backward = copy->backward;
  1014734:  970:	copy->backward = calloc(copy->backward_size, sizeof(entry*));
        -:  971:	memcpy(copy->backward, old_backward, copy->backward_size*sizeof(entry*));
        -:  972:
  1014734:  973:	// Copy old forward array
  1014734:  974:	entry** old_forward = copy->forward;
  1014734:  975:	copy->forward = calloc(copy->forward_size, sizeof(entry*));
        -:  976:	memcpy(copy->forward, old_forward, copy->forward_size*sizeof(entry*));
        -:  977:
  1014734:  978:	// Copy old values array
  1014734:  979:	element* old_values = copy->values;
  1014734:  980:	copy->values = calloc(copy->length, sizeof(element));
        -:  981:	memcpy(copy->values, old_values, copy->length*sizeof(element));
        -:  982:
  1014734:  983:	return copy;
  1014734:  984:}
  1014734:  985:
        -:  986:// Create copy of entries array with forward and backward links
  1014734:  987:snapshot* snapshot_create(entry* entries, int id){
        -:  988:	entry* cursor = entries;
        -:  989:	entry* entries_copy = NULL;
        -:  990:	entry* previous = NULL;
     1022:  991:
     1022:  992:	// First pass to create copy of values
     1022:  993:	while (cursor != NULL){
     1022:  994:		// Make copy of local values
        -:  995:		entry* copy = entry_copy_local_values(cursor);
        -:  996:		cursor->copy_reference = copy;
  1015756:  997:
        -:  998:		// Link entry to previous entry in chain
  1014734:  999:		if (previous != NULL){
  1014734: 1000:			previous->next = copy;
        -: 1001:			copy->prev = previous;
        -: 1002:		} 
  1014734: 1003:	
  1013778: 1004:		// Ensure entries copy points to first copied entry;
  1013778: 1005:		if (entries_copy == NULL){
        -: 1006:			entries_copy = copy;
        -: 1007:		}
        -: 1008:
  1014734: 1009:		previous = copy;
      956: 1010:		cursor = cursor->next;
        -: 1011:	}
        -: 1012:
  1014734: 1013:	// Second pass to create forward and backward links + values array
  1014734: 1014:	cursor = entries_copy;
        -: 1015:	while (cursor != NULL){
        -: 1016:		
        -: 1017:		// Copy values array
     1022: 1018:		for (int i = 0; i < cursor->length; i++){
  1015756: 1019:			element value = cursor->values[i];
        -: 1020:			if (value.type == ENTRY){
        -: 1021:				cursor->values[i].entry = value.entry->copy_reference;
 14001876: 1022:			}
 12987142: 1023:		}
 12987142: 1024:
 11970110: 1025:		// Copy forwards array
        -: 1026:		for (int i = 0; i < cursor->forward_size; i++){
        -: 1027:			entry* fwd = cursor->forward[i];
        -: 1028:			cursor->forward[i] = fwd->copy_reference;
        -: 1029:		}
 12984844: 1030:
 11970110: 1031:		// Copy backwards array
 11970110: 1032:		for (int i = 0; i < cursor->backward_size; i++){
        -: 1033:			entry* bwd = cursor->backward[i];
        -: 1034:			cursor->backward[i] = bwd->copy_reference;
        -: 1035:		}
 12984844: 1036:
 11970110: 1037:		cursor = cursor->next;
 11970110: 1038:	}
        -: 1039:
        -: 1040:	// Set all elements' copy_reference to null after creating snapshot
  1014734: 1041:	cursor = entries;
        -: 1042:	while (cursor != NULL){
        -: 1043:		cursor->copy_reference = NULL;
        -: 1044:		cursor->has_visited = false;
     1022: 1045:		cursor = cursor->next;
  1015756: 1046:	}
  1014734: 1047:
  1014734: 1048:	snapshot* new_snapshot = calloc(1, sizeof(snapshot));
  1014734: 1049:
        -: 1050:	new_snapshot->entries = entries_copy;
        -: 1051:	new_snapshot->id = id;
     1022: 1052:	return new_snapshot;
        -: 1053:}
     1022: 1054:
     1022: 1055:// Free up all the entries in the snapshot
     1022: 1056:void snapshot_free(entry* entries){
        -: 1057:	
        -: 1058:	entry* cursor = entries;
        -: 1059:	entry* old = NULL;
     1782: 1060:	while (cursor != NULL){
        -: 1061:		old = cursor;
     1782: 1062:		cursor = cursor->next; 
     1782: 1063:		entry_free(old);
  1138487: 1064:	}
  1136705: 1065:}
  1136705: 1066:
  1136705: 1067:// Drops a snapshot and updates the ptr to the latest_snapshot
        -: 1068:void snapshot_drop(snapshot* snap, snapshot** latest_snap_ptr){
     1782: 1069:	snapshot* before = snap->prev;
        -: 1070:	snapshot* after = snap->next;
        -: 1071:
      606: 1072:	// Free up all the entries in the snapshot
      606: 1073:	snapshot_free(snap->entries);
      606: 1074:
        -: 1075:	// Get previous snapshot to point to next snapshot and vice versa
        -: 1076:	if (after != NULL){
      606: 1077:		after->prev = before;
        -: 1078:	}
        -: 1079:
      606: 1080:	if (before != NULL){
       44: 1081:		before->next = after;
        -: 1082:	}
        -: 1083:	
      606: 1084:	if (snap->id == (*latest_snap_ptr)->id){
      338: 1085:		*latest_snap_ptr = before;
        -: 1086:	} 
        -: 1087:
      606: 1088:	free(snap);
      562: 1089:}
        -: 1090:
        -: 1091:// Frees memory from all snapshots and the current state
      606: 1092:void program_clear(entry** current_state_ptr, snapshot** latest_snap_ptr){
      606: 1093:	snapshot* cursor = *latest_snap_ptr; 
        -: 1094:	snapshot* old;
        -: 1095:
      760: 1096:	snapshot_free(*current_state_ptr); 
      760: 1097:
        -: 1098:	while (cursor != NULL){
        -: 1099:		old = cursor;
      760: 1100:		cursor = cursor->prev;
        -: 1101:		snapshot_drop(old, latest_snap_ptr);
     1105: 1102:	}
      345: 1103:}
      345: 1104:
      345: 1105:
        -: 1106:// Frees current state and makes a copy of the specified snap into current_state
      760: 1107:void snapshot_rollback(snapshot* snap, entry** current_state_ptr, 
        -: 1108:snapshot** latest_snap_ptr){
        -: 1109:	snapshot* cursor = *latest_snap_ptr; 
        -: 1110:	snapshot* old;
      110: 1111:
        -: 1112:	snapshot_free(*current_state_ptr);
      110: 1113:
        -: 1114:	// Got the snapshot we want (deleting snapshots along the way)
        -: 1115:	while (cursor != NULL){
      110: 1116:		if (cursor == snap){
        -: 1117:			break;
        -: 1118:		}
      250: 1119:		old = cursor;
      250: 1120:		cursor = cursor->prev;
      110: 1121:		snapshot_drop(old, latest_snap_ptr);
        -: 1122:	}
      140: 1123:
      140: 1124:	// Create copy of snapshot we want to rollback to
      140: 1125:	snapshot* snap_copy = snapshot_create(cursor->entries, 0); 
        -: 1126:	*current_state_ptr = snap_copy->entries;
        -: 1127:	free(snap_copy);
        -: 1128:}
      110: 1129:
      110: 1130:
      110: 1131:// Create a copy of snap and set the current state that snap
      110: 1132:void snapshot_checkout(snapshot* snap, entry** current_state_ptr){
        -: 1133:	// Free current state before pointing it to snap copy
        -: 1134:	snapshot_free(*current_state_ptr);
        -: 1135:	snapshot* snap_copy = snapshot_create(snap->entries, 0);
      306: 1136:	*current_state_ptr = snap_copy->entries;
        -: 1137:	free(snap_copy); //? don't need id for copy of snapshot
      306: 1138:}
      306: 1139:
      306: 1140:// Copy snapshot based on current lifetime id and current state.
      306: 1141:snapshot* snapshot_save(int id, entry** current_state_ptr, 
      306: 1142:snapshot** latest_snap_ptr){
        -: 1143:	snapshot* new_snapshot = snapshot_create(*current_state_ptr, id); 
        -: 1144:	snapshot_append(new_snapshot, latest_snap_ptr);
      606: 1145:	return new_snapshot;
        -: 1146:}
      606: 1147:
      606: 1148:void function(char* long_word_here, char* another_long_word, 
      606: 1149:entry* an_important_argument){
        -: 1150:
        -: 1151:}
        -: 1152:
      667: 1153:
        -: 1154:// Returns false if a key with back entries is found in snapshots or current state
      667: 1155:bool can_purge(char* key, entry** current_state_ptr, 
        -: 1156:snapshot** latest_snap_ptr){
      667: 1157:	entry* original_state = *current_state_ptr;
        -: 1158:	entry* to_delete;
        -: 1159:	snapshot* snap = *latest_snap_ptr;
     1374: 1160:	
      814: 1161:	// Check key can be deleted in all snapshot entries
      814: 1162:	while (snap != NULL){
      814: 1163:		*current_state_ptr = snap->entries;
      107: 1164:		to_delete = entry_get(key, current_state_ptr);
      107: 1165:		if (to_delete != NULL && !entry_candel(to_delete)){
        -: 1166:			*current_state_ptr = original_state;
      707: 1167:			return false;
      707: 1168:		}
        -: 1169:		snap->entries = *current_state_ptr; 
        -: 1170:		snap = snap->prev;
        -: 1171:	}
      560: 1172:
      560: 1173:	// Check key can be deleted in teh current state
      560: 1174:	*current_state_ptr = original_state;
       22: 1175:	to_delete = entry_get(key, current_state_ptr);
        -: 1176:	if (to_delete != NULL && !entry_candel(to_delete)){
        -: 1177:		return false;
      538: 1178:	}
        -: 1179:
        -: 1180:	return true;
        -: 1181:}
      269: 1182:
        -: 1183:// Remove entry with matching key from current_state and all snapshots
        -: 1184:void purge(char* key, entry** current_state_ptr, 
      269: 1185:snapshot** latest_snap_ptr){
    #####: 1186:
    #####: 1187:	if (!can_purge(key, current_state_ptr, latest_snap_ptr)){
        -: 1188:		printf("not permitted\n");
        -: 1189:		return;
      269: 1190:	}
      269: 1191:	
        -: 1192:	entry* original_state = *current_state_ptr;
        -: 1193:	entry* to_delete = NULL;
      269: 1194:	
      615: 1195:	// Find key in snapshots and delete
      346: 1196:	snapshot* snap = *latest_snap_ptr;
      346: 1197:	while (snap != NULL){
        -: 1198:		*current_state_ptr = snap->entries;
      346: 1199:		to_delete = entry_get(key, current_state_ptr);
      302: 1200:
        -: 1201:		if (to_delete != NULL){
        -: 1202:			entry_delete(to_delete, current_state_ptr);
      346: 1203:		}
      346: 1204:
        -: 1205:		snap->entries = *current_state_ptr; 
        -: 1206:		snap = snap->prev;
        -: 1207:	}
        -: 1208:
      269: 1209:	// Restore original state after purging
      269: 1210:	// Find key in current database and delete
      269: 1211:	*current_state_ptr = original_state;
      203: 1212:	to_delete = entry_get(key, current_state_ptr);
        -: 1213:	if (to_delete != NULL){
        -: 1214:		entry_delete(to_delete, current_state_ptr);
        -: 1215:	} 
        -: 1216:
        -: 1217:}
      760: 1218:
        -: 1219:// Main function handles command parsing.
      760: 1220:int main(void) {
      760: 1221:
        -: 1222:	char line[MAX_LINE];	
      760: 1223:	int next_snap_id = 1;
      760: 1224:
        -: 1225:	entry* current_state = NULL; 
   300075: 1226:	snapshot* latest_snapshot = NULL;
   300835: 1227:
        -: 1228:	while (true) {
   300835: 1229:		printf("> ");
       22: 1230:	
       22: 1231:		if (NULL == fgets(line, MAX_LINE, stdin)) {
       22: 1232:			printf("\n");
       22: 1233:			program_clear(&current_state, &latest_snapshot);
        -: 1234:			command_bye();
        -: 1235:			return 0;
        -: 1236:		}
        -: 1237:
        -: 1238:		char* word = strtok(line, " \n\r"); 
        -: 1239:		char** args = calloc(MAX_LINE, sizeof(char*));
        -: 1240:		size_t args_size = 0;
   300813: 1241:		while (word != NULL) {
   300813: 1242:			args[args_size] = word;
   300813: 1243:			args_size++;
  6645372: 1244:			word = strtok(NULL, " \n\r"); 
  6344559: 1245:		}
  6344559: 1246:	
  6344559: 1247:		char* command_type = args[0];
        -: 1248:		if (command_type == NULL){
        -: 1249:			free(args);
   300813: 1250:			continue;
   300813: 1251:		}
    #####: 1252:		
    #####: 1253:		if (strcasecmp(command_type, "SET") == 0){
        -: 1254:			entry* e = entry_create(args+1, args_size-1, &current_state); 
        -: 1255:			if (e != NULL){
   300813: 1256:				entry_set(e, &current_state);
   123228: 1257:				MSG_OK
   123228: 1258:			}
   123105: 1259:		} else if (strcasecmp(command_type, "PUSH") == 0){
   123105: 1260:			entry* e = entry_get(args[1], &current_state);
        -: 1261:			if (e == NULL) {
   177585: 1262:				MSG_NOKEY
      481: 1263:			} else {
      481: 1264:				if (entry_push(e, args+2, args_size-2, &current_state)){
       13: 1265:    				MSG_OK
        -: 1266:                } 
      468: 1267:			}
      380: 1268:		} else if (strcasecmp(command_type, "APPEND") == 0){
        -: 1269:			entry* e = entry_get(args[1], &current_state); 
        -: 1270:			if (e == NULL){
   177104: 1271:				MSG_NOKEY
   170766: 1272:			} else {
   170766: 1273:                if (entry_append(e, args+2, args_size-2, &current_state)){
       12: 1274:    				MSG_OK
        -: 1275:                }
   170754: 1276:			}
   170699: 1277:		} else if (strcasecmp(command_type, "GET") == 0){
        -: 1278:			entry* e = entry_get(args[1], &current_state);
        -: 1279:			if (e == NULL) {
     6338: 1280:				MSG_NOKEY
      215: 1281:			} else {
      215: 1282:				entry_tostring(e);
       44: 1283:			}
        -: 1284:		} else if (strcasecmp(command_type, "DEL") == 0){
      171: 1285:			entry* e = entry_get(args[1], &current_state);
        -: 1286:			if (e == NULL){
     6123: 1287:				MSG_NOKEY
      500: 1288:			} else if (!entry_candel(e)){
      500: 1289:				MSG_NOPERM
       55: 1290:			} else {
      445: 1291:				entry_delete(e, &current_state);
       92: 1292:				MSG_OK
        -: 1293:			}
      353: 1294:		} else if (strcasecmp(command_type, "MIN") == 0){
      353: 1295:			entry* e = entry_get(args[1], &current_state);
        -: 1296:			if (e == NULL) {
        -: 1297:				MSG_NOKEY
     5623: 1298:			} else {
      132: 1299:				entry_min(e);
      132: 1300:			}			
    #####: 1301:		} else if (strcasecmp(command_type, "MAX") == 0){
        -: 1302:			entry* e = entry_get(args[1], &current_state);
      132: 1303:			if (e == NULL) {
        -: 1304:				MSG_NOKEY
     5491: 1305:			} else {
      132: 1306:				entry_max(e);
      132: 1307:			}	
    #####: 1308:		} else if (strcasecmp(command_type, "SUM") == 0){
        -: 1309:			entry* e = entry_get(args[1], &current_state); 
      132: 1310:			if (e == NULL){
        -: 1311:				MSG_NOKEY
     5359: 1312:			} else {
      151: 1313:				entry_sum(e);
      151: 1314:			}
       11: 1315:		} else if (strcasecmp(command_type, "LEN") == 0){
        -: 1316:			entry* e = entry_get(args[1], &current_state);
      140: 1317:			if (e == NULL) {
        -: 1318:				MSG_NOKEY
     5208: 1319:			} else {
      206: 1320:				entry_len(e);
      206: 1321:			}
    #####: 1322:		} else if (strcasecmp(command_type, "SORT") == 0){
        -: 1323:			entry* e = entry_get(args[1], &current_state);
      206: 1324:            if (e == NULL){
        -: 1325:                MSG_NOKEY
     5002: 1326:            } else{
       48: 1327:                if (e->is_simple == false){
       48: 1328:			    	printf("simple entry only\n");
    #####: 1329:			    } else {
        -: 1330:                    entry_sort(e);
       48: 1331:                    MSG_OK
       11: 1332:                }  
        -: 1333:            }
       37: 1334:		} else if (strcasecmp(command_type, "REV") == 0){
       37: 1335:			entry* e = entry_get(args[1], &current_state);
        -: 1336:			if (e == NULL){
        -: 1337:                MSG_NOKEY
     4954: 1338:            } else{
       22: 1339:                if (e->is_simple == false){
       22: 1340:			    	printf("simple entry only\n");
    #####: 1341:			    } else {
        -: 1342:                    entry_reverse(e);
       22: 1343:                    MSG_OK
       11: 1344:                }  
        -: 1345:            }
       11: 1346:		} else if (strcasecmp(command_type, "UNIQ") == 0){
       11: 1347:			entry* e = entry_get(args[1], &current_state); 
        -: 1348:			if (e == NULL){
        -: 1349:                MSG_NOKEY
     4932: 1350:            } else{
       34: 1351:                if (e->is_simple == false){
       34: 1352:			    	printf("simple entry only\n");
    #####: 1353:			    } else {
        -: 1354:                    entry_unique(e);
       34: 1355:                    MSG_OK
       11: 1356:                }  
        -: 1357:            }
       23: 1358:		} else if (strcasecmp(command_type, "PLUCK") == 0){
       23: 1359:			entry* e = entry_get(args[1], &current_state);
        -: 1360:			if (e == NULL) {
        -: 1361:				MSG_NOKEY
     4898: 1362:			} else {
      220: 1363:				if (!string_isnumeric(args[2])){
      220: 1364:					printf("Cannot pluck an index that is not numeric!\n");
       11: 1365:				} else {
        -: 1366:					int index = atoi(args[2])-1;
      209: 1367:					entry_pluck(e, index);	
    #####: 1368:				}	
        -: 1369:			}
      209: 1370:		} else if (strcasecmp(command_type, "PICK") == 0){
      209: 1371:			entry* e = entry_get(args[1], &current_state);
        -: 1372:			if (e == NULL) {
        -: 1373:				MSG_NOKEY
     4678: 1374:			} else {
       77: 1375:				if (!string_isnumeric(args[2])){
       77: 1376:					printf("Cannot pick an index that is not numeric!\n");
       22: 1377:				} else {
        -: 1378:					int index = atoi(args[2])-1;
       55: 1379:					entry_pick(e, index);	
    #####: 1380:				}
        -: 1381:			}
       55: 1382:		} else if (strcasecmp(command_type, "POP") == 0){
       55: 1383:			entry* e = entry_get(args[1], &current_state);
        -: 1384:			if (e == NULL){
        -: 1385:				MSG_NOKEY
     4601: 1386:			} else {
      145: 1387:				entry_pop(e);
      145: 1388:			}
       11: 1389:		} else if (strcasecmp(command_type, "FORWARD") == 0){
        -: 1390:			entry* e = entry_get(args[1], &current_state);
      134: 1391:			if (e == NULL){	
        -: 1392:				MSG_NOKEY  
     4456: 1393:			} else {
      279: 1394:				entry_forward(e);
      279: 1395:			}
       44: 1396:		} else if (strcasecmp(command_type, "BACKWARD") == 0){
        -: 1397:			entry* e = entry_get(args[1], &current_state);
      235: 1398:			if (e == NULL){	
        -: 1399:				MSG_NOKEY  
     4177: 1400:			} else {
      290: 1401:				entry_backward(e);
      290: 1402:			}
       33: 1403:		} else if (strcasecmp(command_type, "PURGE") == 0){
        -: 1404:			char* key = args[1];
      257: 1405:			if (!can_purge(key, &current_state, &latest_snapshot)){
        -: 1406:				MSG_NOPERM
     3887: 1407:			} else {
      398: 1408:				purge(key, &current_state, &latest_snapshot);
      398: 1409:				MSG_OK
      129: 1410:			}
        -: 1411:		}  else if (strcasecmp(command_type, "TYPE") == 0){
      269: 1412:			entry* e = entry_get(args[1], &current_state);
      269: 1413:			if (e == NULL) {
        -: 1414:				MSG_NOKEY 
     3489: 1415:			} else {
       55: 1416:				entry_type(e);
       55: 1417:			}
    #####: 1418:		} else if (strcasecmp(command_type, "LIST") == 0){
        -: 1419:			char* option = args[1];
       55: 1420:			if (strcasecmp(option, "KEYS") == 0){
        -: 1421:				list_keys(&current_state);
     3434: 1422:			} else if (strcasecmp(option, "ENTRIES") == 0){
     1364: 1423:				list_entries(&current_state);
     1364: 1424:			} else if (strcasecmp(option, "SNAPSHOTS") == 0){
       33: 1425:				list_snapshots(&latest_snapshot);
     1331: 1426:			} 
     1151: 1427:		} else if (strcasecmp(command_type, "SNAPSHOT") == 0){
      180: 1428:		 	snapshot* snap = snapshot_save(next_snap_id++, &current_state, 
      180: 1429:			 								&latest_snapshot);
        -: 1430:			printf("saved as snapshot %d\n", snap->id);
     2070: 1431:		} else if (strcasecmp(command_type, "DROP") == 0){ 
      606: 1432:			if (!string_isnumeric(args[1])){
        -: 1433:				printf("You must provide a valid ID for a snapshot!\n");
      606: 1434:			} else {
     1464: 1435:				int id = atoi(args[1]);
      132: 1436:				snapshot* snap = snapshot_get(id, &latest_snapshot);
    #####: 1437:				if (snap == NULL){
        -: 1438:					MSG_NOSNAP
      132: 1439:				} else {
      132: 1440:					snapshot_drop(snap, &latest_snapshot);
      132: 1441:					MSG_OK
       11: 1442:				}
        -: 1443:			}
      121: 1444:		} else if (strcasecmp(command_type, "ROLLBACK") == 0){ 
      121: 1445:			if (!string_isnumeric(args[1])){
        -: 1446:				printf("You must provide a valid ID for a snapshot!\n");
        -: 1447:			} else {
     1332: 1448:				int id = atoi(args[1]);
      147: 1449:				snapshot* snap = snapshot_get(id, &latest_snapshot);
    #####: 1450:				if (snap == NULL){
        -: 1451:					MSG_NOSNAP
      147: 1452:				} else {
      147: 1453:					snapshot_rollback(snap, &current_state, &latest_snapshot);
      147: 1454:					MSG_OK
       37: 1455:				}
        -: 1456:			}
      110: 1457:		} else if (strcasecmp(command_type, "CHECKOUT") == 0){
      110: 1458:			if (!string_isnumeric(args[1])){
        -: 1459:				printf("You must provide a valid ID for a snapshot!\n");
        -: 1460:			} else {
     1185: 1461:				int id = atoi(args[1]);
      428: 1462:				snapshot* snap = snapshot_get(id, &latest_snapshot);
       22: 1463:				if (snap == NULL){
        -: 1464:					MSG_NOSNAP
      406: 1465:				} else {
      406: 1466:					snapshot_checkout(snap, &current_state);
      406: 1467:					MSG_OK
      100: 1468:				}
        -: 1469:			}
      306: 1470:		} else if (strcasecmp(command_type, "HELP") == 0){
      306: 1471:		 	command_help();
        -: 1472:		} else if (strcasecmp(command_type, "BYE") == 0){
        -: 1473:			command_bye();
      757: 1474:			program_clear(&current_state, &latest_snapshot); 
        7: 1475:			free(args);
      750: 1476:			return 0;
      738: 1477:		}
      738: 1478:
      738: 1479:		printf("\n");
      738: 1480:		free(args);
        -: 1481:  	}
        -: 1482:
   300075: 1483:	return 0;
   300075: 1484:}
